JavaClassDiagramDrawer initialized
CppClassDiagramDrawer initialized
CodeController set in UmlController
CodeController set in UmlController
Selected language: C++
UmlController set in ClassDialogController
Opening Class Dialog
Java checkbox state: false
C++ checkbox state: true
Java selected: false
C++ selected: true
Creating C++ class: A
DEBUG: Starting C++ code analysis
DEBUG: Entering class specifier
DEBUG: Created class: A
DEBUG: Added new class to extracted classes: A
DEBUG: Processing access specifier
DEBUG: Visibility changed to: public
DEBUG: Processing member declaration
DEBUG: Processing member declaration
DEBUG: Processing access specifier
DEBUG: Visibility changed to: protected
DEBUG: Processing access specifier
DEBUG: Visibility changed to: private
DEBUG: Exiting class specifier
DEBUG: Completed C++ code analysis
DEBUG: Extracted 1 classes

Class: A
Attributes: 0
Operations: 2
DEBUG: Processing C++ file: A.h
DEBUG: selectedClassName = A
CppModel classes: 1
  Class: A
  Attributes: []
  Operations: [+ A(), + ~A()]
  Relations: 
DEBUG: CppClassDiagramDrawer - Number of classes: 1
Generated PlantUML:
@startuml
 skinparam linetype ortho
skinparam classAttributeIconSize 0
skinparam LineThickness 1.5
hide empty members
skinparam enumBackgroundColor White
skinparam enumBorderColor Black
scale 1.0
class A #90EE90 {
  + A()
  + {virtual} ~A()
}

@enduml

DEBUG: CppClassDiagramDrawer draw completed
Saving scroll position - X: 0.0, Y: 0.0
Restored scroll position - X: 0.0, Y: 0.0
Zoom set to: 0.9860294117647059
Zoom set to: 0.9580882352941177
Zoom set to: 0.9441176470588235
Zoom set to: 0.9161764705882353
Zoom set to: 0.9022058823529412
Zoom set to: 0.8742647058823529
Zoom set to: 0.8463235294117647
Zoom set to: 0.8044117647058824
Zoom set to: 0.776470588235294
Zoom set to: 0.7625
Zoom set to: 0.7485294117647059
Zoom set to: 0.7205882352941176
Zoom set to: 0.7066176470588236
Zoom set to: 0.6926470588235295
Zoom set to: 0.6647058823529411
Zoom set to: 0.6507352941176471
Zoom set to: 0.636764705882353
Zoom set to: 0.6227941176470589
Zoom set to: 0.6088235294117648
Zoom set to: 0.6227941176470589
Zoom set to: 0.6507352941176471
Zoom set to: 0.6647058823529411
Zoom set to: 0.6786764705882353
Zoom set to: 0.6926470588235295
Zoom set to: 0.7066176470588236
Zoom set to: 0.7205882352941176
Zoom set to: 0.7345588235294117
Zoom set to: 0.7625
Zoom set to: 0.776470588235294
Zoom set to: 0.8044117647058824
Zoom set to: 0.8323529411764705
Zoom set to: 0.8742647058823529
Zoom set to: 0.9161764705882353
Zoom set to: 0.9301470588235294
Zoom set to: 0.9720588235294118
Zoom set to: 1.013970588235294
Zoom set to: 1.0419117647058824
Zoom set to: 1.0558823529411765
Zoom set to: 1.0698529411764706
Zoom set to: 1.097794117647059
Zoom set to: 1.111764705882353
Zoom set to: 1.125735294117647
Zoom set to: 1.1397058823529411
Zoom set to: 1.1536764705882354
Zoom set to: 1.1676470588235295
Zoom set to: 1.1816176470588236
Zoom set to: 1.2375
Zoom set to: 1.2933823529411765
Zoom set to: 1.3073529411764706
Zoom set to: 1.3213235294117647
Zoom set to: 1.335294117647059
Zoom set to: 1.349264705882353
Zoom set to: 1.3772058823529412
Zoom set to: 1.4051470588235295
Zoom set to: 1.4330882352941177
Zoom set to: 1.4470588235294117
Zoom set to: 1.475
Zoom set to: 1.4889705882352942
Zoom set to: 1.5029411764705884
Zoom set to: 1.5169117647058825
Zoom set to: 1.5308823529411766
Zoom set to: 1.5448529411764707
Zoom set to: 1.5588235294117647
Zoom set to: 1.5727941176470588
Zoom set to: 1.586764705882353
Zoom set to: 1.6007352941176471
Zoom set to: 1.6147058823529414
Zoom set to: 1.6286764705882355
Zoom set to: 1.6426470588235296
Zoom set to: 1.6705882352941177
Zoom set to: 1.6845588235294118
Zoom set to: 1.698529411764706
DEBUG: Starting Reload
DEBUG: Found 1 header files
DEBUG: Processing A.h
DEBUG: Starting C++ code analysis
DEBUG: Entering class specifier
DEBUG: Created class: A
DEBUG: Added new class to extracted classes: A
DEBUG: Processing access specifier
DEBUG: Visibility changed to: public
DEBUG: Processing member declaration
DEBUG: Starting Reload
DEBUG: Found 1 header files
DEBUG: Processing A.h
DEBUG: Processing member declaration
DEBUG: Updating diagram
DEBUG: Refresh completed
DEBUG: Processing access specifier
DEBUG: Visibility changed to: protected
DEBUG: Processing access specifier
DEBUG: Visibility changed to: private
DEBUG: Starting Reload
DEBUG: Found 1 header files
DEBUG: Processing A.h
DEBUG: Exiting class specifier
DEBUG: Completed C++ code analysis
DEBUG: Extracted 1 classes

Class: A
Attributes: 0
Operations: 2
DEBUG: Starting C++ code analysis
DEBUG: Entering class specifier
DEBUG: Created class: A
DEBUG: Updating diagram
DEBUG: Refresh completed
DEBUG: Added new class to extracted classes: A
DEBUG: Processing access specifier
DEBUG: Starting Reload
DEBUG: Visibility changed to: public
DEBUG: Found 1 header files
DEBUG: Processing A.h
DEBUG: Processing member declaration
DEBUG: Starting Reload
DEBUG: Found 1 header files
DEBUG: Processing A.h
DEBUG: Updating diagram
DEBUG: Refresh completed
DEBUG: Updating diagram
DEBUG: Refresh completed
DEBUG: Processing member declaration
DEBUG: Processing access specifier
DEBUG: Visibility changed to: protected
DEBUG: Processing access specifier
DEBUG: Visibility changed to: private
DEBUG: Exiting class specifier
DEBUG: Completed C++ code analysis
DEBUG: Extracted 1 classes

Class: A
Attributes: 0
Operations: 2
DEBUG: Starting C++ code analysis
DEBUG: Entering class specifier
DEBUG: Created class: A
DEBUG: Added new class to extracted classes: A
DEBUG: Processing access specifier
DEBUG: Visibility changed to: public
DEBUG: Processing member declaration
DEBUG: Processing member declaration
DEBUG: Processing access specifier
DEBUG: Visibility changed to: protected
DEBUG: Processing access specifier
DEBUG: Visibility changed to: private
DEBUG: Exiting class specifier
DEBUG: Completed C++ code analysis
DEBUG: Extracted 1 classes

Class: A
Attributes: 0
Operations: 2
DEBUG: Updating diagram
DEBUG: Refresh completed
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.common;

public interface FileChangeListener {
    void onFileChanged(ICodeFile file);

    void onFileNameChanged(String oldName, String newName);
}
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.common;

import io.github.morichan.retuss.controller.CodeController;
import io.github.morichan.retuss.controller.UmlController;
import io.github.morichan.retuss.model.uml.Class;
import io.github.morichan.retuss.model.uml.CombinedFragment;
import io.github.morichan.retuss.model.uml.Message;
import io.github.morichan.retuss.model.uml.InteractionFragment;
import io.github.morichan.fescue.feature.Attribute;
import io.github.morichan.fescue.feature.Operation;

import java.util.*;

public abstract class AbstractJavaModel {
    protected UmlController umlController;
    protected CodeController codeController;

    public void setUmlController(UmlController umlController) {
        this.umlController = umlController;
    }

    public void setCodeController(CodeController codeController) {
        this.codeController = codeController;
    }

    public Optional<Class> findClass(String className) {
        for (ICodeFile codeFile : getCodeFileList()) {
            for (Class umlClass : codeFile.getUmlClassList()) {
                if (umlClass.getName().equals(className)) {
                    return Optional.of(umlClass);
                }
            }
        }
        return Optional.empty();
    }

    public List<Class> getUmlClassList() {
        List<Class> umlClassList = new ArrayList<>();
        for (ICodeFile codeFile : getCodeFileList()) {
            umlClassList.addAll(codeFile.getUmlClassList());
        }
        return Collections.unmodifiableList(umlClassList);
    }

    // 言語固有の実装が必要なメソッド
    protected abstract List<? extends ICodeFile> getCodeFileList();

    public abstract void addNewCodeFile(String fileName);

    public abstract void addNewUmlClass(Class umlClass);

    public abstract void addCombinedFragment(String className, Operation operation, CombinedFragment combinedFragment);

    public abstract void updateCodeFile(ICodeFile changedCodeFile, String code);

    public abstract void addAttribute(String className, Attribute attribute);

    public abstract void addOperation(String className, Operation operation);

    public abstract void addComposition(String haveClassName, String compositedClassName);

    public abstract void addGeneralization(String generalizedClassName, String superClassName);

    public abstract void delete(String className);

    public abstract void delete(String className, Attribute attribute);

    public abstract void delete(String className, Operation operation);

    public abstract void delete(String className, Operation operation, InteractionFragment interactionFragment);

    public abstract void deleteSuperClass(String className);

    public abstract void addMessage(String className, Operation operation, Message message);
}
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.common;

import io.github.morichan.retuss.model.uml.Class;
import java.util.*;

public interface ICodeFile {
    UUID getID();

    String getFileName();

    String getCode();

    List<Class> getUmlClassList();

    void updateCode(String code);

    void addUmlClass(Class umlClass);

    void removeClass(Class umlClass);

    default List<? extends ICodeFile> getFiles() {
        return Collections.singletonList(this);
    }

    // ファイルの種類を判別するためのメソッド
    default boolean isMainFile() {
        return true;
    }
}
DEBUG: Updating Java code:
package io.github.morichan.retuss.model;

import java.util.ArrayList;
import java.util.List;

public class UmlModel {
    private static final UmlModel instance = new UmlModel();
    private String currentPlantUml;
    private final List<UmlChangeListener> changeListeners = new ArrayList<>();

    private UmlModel() {
        this.currentPlantUml = "";
    }

    public static UmlModel getInstance() {
        return instance;
    }

    public interface UmlChangeListener {
        void onUmlChanged(String newPlantUml);
    }

    public void setPlantUml(String plantUml) {
        this.currentPlantUml = plantUml;
        notifyUmlChanged();
    }

    public String getPlantUml() {
        return currentPlantUml;
    }

    public void addChangeListener(UmlChangeListener listener) {
        changeListeners.add(listener);
    }

    private void notifyUmlChanged() {
        for (UmlChangeListener listener : changeListeners) {
            listener.onUmlChanged(currentPlantUml);
        }
    }
}
DEBUG: Updating Java code:
package io.github.morichan.retuss.model;

import io.github.morichan.fescue.feature.Operation;
import io.github.morichan.retuss.controller.UmlController;
import io.github.morichan.retuss.model.uml.cpp.*;
import io.github.morichan.retuss.model.uml.cpp.utils.Modifier;
import io.github.morichan.retuss.translator.cpp.CppTranslator;

import java.util.*;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;

public class CppFile {
    private final ExecutorService analysisExecutor = Executors.newSingleThreadExecutor(); // 解析用の専用スレッド
    private final ScheduledExecutorService updateExecutor = Executors.newSingleThreadScheduledExecutor(); // 更新用のスレッド
    private Future<?> lastTask; // 最後の非同期タスクを追跡
    private final Object updateLock = new Object(); // 同期処理用ロック
    private final UUID ID = UUID.randomUUID();
    private String fileName = "";
    private String sourceCode;
    private final List<CppHeaderClass> headerClasses = new ArrayList<>();
    private CppImplClass implClass;
    private CppTranslator translator;
    private final boolean isHeader;
    private final List<FileChangeListener> listeners = new ArrayList<>();

    private UmlController umlController;

    public CppFile(String fileName, boolean isHeader) {
        this.fileName = fileName;
        this.isHeader = isHeader;
        this.translator = new CppTranslator();
        if (isHeader) {
            // 初期のヘッダークラスを追加
            CppHeaderClass headerClass = new CppHeaderClass(getBaseName());
            headerClasses.add(headerClass);
        }
        initializeFile();
    }

    public void setUmlController(UmlController controller) {
        this.umlController = controller;
    }

    private void initializeFile() {
        if (isHeader) {
            initializeHeaderFile();
        } else {
            initializeImplementationFile();
        }

        // 初期化後にUMLクラスリストを更新（ヘッダーファイルのみ）
        if (isHeader && sourceCode != null) {
            headerClasses.clear();
            headerClasses.addAll(translator.translateHeaderCodeToUml(sourceCode));
        }
    }

    // ファイルの種類に応じた初期化の改善
    private void initializeHeaderFile() {
        String className = fileName.replace(".h", "");

        StringBuilder sb = new StringBuilder();
        String guardName = className.toUpperCase() + "_H";

        sb.append("#ifndef ").append(guardName).append("\n");
        sb.append("#define ").append(guardName).append("\n\n");
        sb.append("class ").append(className).append(" {\n");
        sb.append("public:\n");
        sb.append("    ").append(className).append("();\n");
        sb.append("    virtual ~").append(className).append("();\n");
        sb.append("\nprotected:\n");
        sb.append("\nprivate:\n");
        sb.append("};\n\n");
        sb.append("#endif // ").append(guardName).append("\n");

        this.sourceCode = sb.toString();
    }

    private void initializeImplementationFile() {
        String className = fileName.replace(".cpp", "");
        StringBuilder sb = new StringBuilder();
        sb.append("#include \"").append(className).append(".h\"\n\n");
        sb.append(className).append("::").append(className).append("() {\n}\n\n");
        sb.append(className).append("::~").append(className).append("() {\n}\n");

        this.sourceCode = sb.toString();
    }

    public UUID getID() {
        return ID;
    }

    public String getFileName() {
        return fileName;
    }

    public String getCode() {
        return sourceCode != null ? sourceCode : "";
    }

    public List<CppHeaderClass> getHeaderClasses() {
        return isHeader ? Collections.unmodifiableList(headerClasses) : Collections.emptyList();
    }

    public void updateFileName(String newName) {
        if (!this.fileName.equals(newName)) {
            String oldName = this.fileName;
            this.fileName = newName;
            System.out.println("DEBUG: CppFile updating filename from " + oldName + " to " + newName);

            // UmlControllerに通知（null チェック付き）
            if (umlController != null) {
                umlController.updateFileName(oldName, newName);
            } else {
                System.out.println("DEBUG: UmlController is not set");
            }

            notifyFileNameChanged(oldName, newName);
        }
    }

    public void updateCode(String code) {
        // 入力コードの即時反映
        synchronized (updateLock) {
            this.sourceCode = code;
        }

        // 古いタスクをキャンセル
        if (lastTask != null && !lastTask.isDone()) {
            lastTask.cancel(true);
        }
        // 新しい非同期タスクを登録
        lastTask = analysisExecutor.submit(() -> {
            try {
                if (isHeader) {
                    System.out.println("DEBUG: Updating header file code");
                    // クラス名の更新を先に行う
                    Optional<String> newClassName = translator.extractClassName(code);
                    if (newClassName.isPresent()) {
                        String className = newClassName.get();
                        String expectedFileName = className + ".h";
                        if (!expectedFileName.equals(this.fileName)) {
                            String oldFileName = this.fileName;
                            this.fileName = expectedFileName;
                            notifyFileNameChanged(oldFileName, expectedFileName);
                        }
                    }

                    // ヘッダーのUMLクラスリストの更新
                    List<CppHeaderClass> newUmlClassList = translator.translateHeaderCodeToUml(code);
                    System.out.println(
                            "DEBUG: Parsed classes: " + (newUmlClassList != null ? newUmlClassList.size() : "null"));
                    if (!newUmlClassList.isEmpty()) {
                        // リストの内容を更新
                        headerClasses.clear();
                        headerClasses.addAll(newUmlClassList);
                        for (CppHeaderClass cls : this.headerClasses) {
                            if (cls.getAbstruct() && !cls.getOperationList().isEmpty()) {
                                boolean allAbstract = true;
                                for (Operation op : cls.getOperationList()) {
                                    if (!cls.getModifiers(op.getName().getNameText()).contains(Modifier.ABSTRACT)
                                            && !cls.getName().equals(op.getName().getNameText())) {
                                        allAbstract = false;
                                        cls.setInterface(false);
                                        break; // 一度でも修飾子に ABTRACT が含まれていない場合、ループを終了
                                    }
                                }
                                if (allAbstract && cls.getAttributeList().isEmpty()) {
                                    System.out.println("すべての操作が抽象かつ属性が空です。");
                                    cls.setInterface(true);
                                }
                            }

                        }

                        // 対応する実装ファイルからの関係も解析
                        String baseName = getBaseName();
                        CppFile implFile = CppModel.getInstance().findImplFile(baseName);
                        // if (implFile != null) {
                        // analyzeImplementationFile(implFile);
                        // }
                    }
                }

                // UMLコントローラーに通知
                if (umlController != null) {
                    umlController.updateDiagram(this);
                }
                notifyFileChanged();
            } catch (

            CancellationException e) {
                System.out.println("DEBUG: Task was canceled");
            } catch (Exception e) {
                System.err.println("Error during async code update: " + e.getMessage());
                e.printStackTrace();
            }
        });
        try {
            // 非同期タスクが完了するまで待つ
            lastTask.get(); // タスクの完了を待機
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public String getBaseName() {
        return fileName.replaceAll("\\.(h|hpp|cpp)$", "");
    }

    // リソースの解放
    public void shutdown() {
        analysisExecutor.shutdown();
        updateExecutor.shutdown();
    }

    public boolean isHeader() {
        return isHeader;
    }

    public void removeClass(CppHeaderClass cls) {
        System.out.println("Removing class: " + cls.getName());
        // リストの内容を変更
        headerClasses.clear();

        // クラス定義全体を削除
        List<String> lines = new ArrayList<>(Arrays.asList(this.sourceCode.split("\n")));
        int classStart = -1;
        int classEnd = -1;

        // クラスの開始位置を探す
        for (int i = 0; i < lines.size(); i++) {
            if (lines.get(i).contains("class " + cls.getName())) {
                classStart = i;
                break;
            }
        }

        // クラスの終了位置を探す
        if (classStart != -1) {
            for (int i = classStart; i < lines.size(); i++) {
                if (lines.get(i).trim().equals("};")) {
                    classEnd = i;
                    break;
                }
            }
        }

        // クラス定義を削除
        if (classStart != -1 && classEnd != -1) {
            System.out.println("Removing class definition from lines " + classStart + " to " + classEnd);
            lines.subList(classStart, classEnd + 1).clear();
            this.sourceCode = String.join("\n", lines);

            // コードを更新
            updateCode(this.sourceCode);
        }

        System.out.println("Class removal completed");
    }

    public void addChangeListener(FileChangeListener listener) {
        listeners.add(listener);
    }

    // 拡張したファイル変更リスナー
    public interface FileChangeListener {
        void onFileChanged(CppFile file);

        void onFileNameChanged(String oldName, String newName);
    }

    private void notifyFileChanged() {
        System.out.println("DEBUG: Notifying file change for " + fileName);
        for (FileChangeListener listener : listeners) {
            try {
                listener.onFileChanged(this);
            } catch (Exception e) {
                System.err.println("Error in file change notification: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

    private void notifyFileNameChanged(String oldName, String newName) {
        System.out.println("DEBUG: Notifying file name change: " + oldName + " -> " + newName);
        for (FileChangeListener listener : listeners) {
            try {
                listener.onFileNameChanged(oldName, newName);
            } catch (Exception e) {
                System.err.println("Error in file name change notification: " + e.getMessage());
                e.printStackTrace();
            }
        }
    }

}
DEBUG: Updating Java code:
package io.github.morichan.retuss.model;

import io.github.morichan.retuss.model.common.FileChangeListener;
import io.github.morichan.retuss.model.common.ICodeFile;
import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import io.github.morichan.retuss.model.uml.Class;
import io.github.morichan.retuss.translator.JavaTranslator;

import java.util.*;

public class CodeFile implements ICodeFile {
    private final UUID ID = UUID.randomUUID();
    private String fileName = "";
    private CompilationUnit compilationUnit;
    private List<Class> umlClassList = new ArrayList<>();
    private JavaTranslator translator = new JavaTranslator();
    private final List<FileChangeListener> listeners = new ArrayList<>();

    public CodeFile(String fileName) {
        this.fileName = fileName;
        String className = fileName.replace(".java", "");
        this.compilationUnit = new CompilationUnit();
        this.compilationUnit.addClass(className);
        updateUmlClasses(this.compilationUnit);
    }

    @Override
    public UUID getID() {
        return ID;
    }

    @Override
    public String getFileName() {
        return fileName;
    }

    public CompilationUnit getCompilationUnit() {
        return compilationUnit;
    }

    @Override
    public List<Class> getUmlClassList() {
        return Collections.unmodifiableList(umlClassList);
    }

    @Override
    public String getCode() {
        if (Objects.isNull(compilationUnit)) {
            return "";
        }
        return compilationUnit.toString();
    }

    @Override
    public void updateCode(String code) {
        try {
            System.out.println("DEBUG: Updating Java code:\n" + code);

            // コードのパース
            CompilationUnit newUnit = StaticJavaParser.parse(code);
            Optional<ClassOrInterfaceDeclaration> mainClass = newUnit.findFirst(ClassOrInterfaceDeclaration.class);

            mainClass.ifPresent(cls -> {
                String expectedFileName = cls.getNameAsString() + ".java";
                if (!expectedFileName.equals(this.fileName)) {
                    String oldFileName = this.fileName;
                    this.fileName = expectedFileName;
                    notifyFileNameChanged(oldFileName, expectedFileName);
                }
            });

            this.compilationUnit = newUnit;
            updateUmlClasses(newUnit);
            System.out.println("DEBUG: Updated UML classes: " + umlClassList.size());
            for (Class cls : umlClassList) {
                System.out.println("DEBUG: Class: " + cls.getName());
                System.out.println("DEBUG: Attributes: " + cls.getAttributeList().size());
                System.out.println("DEBUG: Operations: " + cls.getOperationList().size());
            }
        } catch (Exception e) {
            System.err.println("Error updating Java code: " + e.getMessage());
            e.printStackTrace();
            throw e;
        }
    }

    private void updateUmlClasses(CompilationUnit unit) {
        List<Class> newClasses = translator.translateCodeToUml(unit.toString());
        umlClassList.clear();
        umlClassList.addAll(newClasses);
    }

    public interface FileNameChangeListener {
        void onFileNameChanged(String oldName, String newName);
    }

    public void addChangeListener(FileChangeListener listener) {
        listeners.add(listener);
    }

    private void notifyFileNameChanged(String oldName, String newName) {
        for (FileChangeListener listener : listeners) {
            listener.onFileNameChanged(oldName, newName);
        }
    }

    @Override
    public void addUmlClass(Class umlClass) {
        this.umlClassList.add(umlClass); // クリアせずに追加
        this.compilationUnit = translator.translateUmlToCode(this.umlClassList); // 更新されたクラスリストからコンパイルユニットを生成
    }

    @Override
    public void removeClass(Class umlClass) {
        this.umlClassList.remove(umlClass);
        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = this.compilationUnit
                .getClassByName(umlClass.getName());
        if (classOrInterfaceDeclarationOptional.isPresent()) {
            this.compilationUnit.remove(classOrInterfaceDeclarationOptional.get());
        }
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model;

import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.BodyDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.ExpressionStmt;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import io.github.morichan.fescue.feature.Attribute;
import io.github.morichan.fescue.feature.Operation;
import io.github.morichan.fescue.feature.name.Name;
import io.github.morichan.fescue.feature.type.Type;
import io.github.morichan.fescue.feature.visibility.Visibility;
import io.github.morichan.retuss.model.common.AbstractJavaModel;
import io.github.morichan.retuss.model.common.ICodeFile;
import io.github.morichan.retuss.model.uml.Class;
import io.github.morichan.retuss.model.uml.*;
import io.github.morichan.retuss.translator.JavaTranslator;

import java.util.*;

/**
 * <p>
 * Java言語用のモデルクラス
 * </p>
 * <p>
 * Singletonパターンを使用
 * </p>
 */
public class JavaModel extends AbstractJavaModel {
    private static JavaModel model = new JavaModel();
    private List<CodeFile> codeFileList = new ArrayList<>();
    private JavaTranslator translator = new JavaTranslator();

    private JavaModel() {
    }

    public static JavaModel getInstance() {
        return model;
    }

    @Override
    protected List<? extends ICodeFile> getCodeFileList() {
        return Collections.unmodifiableList(codeFileList);
    }

    @Override
    public void addNewCodeFile(String fileName) {
        CodeFile newCodeFile = new CodeFile(fileName);
        codeFileList.add(newCodeFile);
        codeController.updateCodeTab(newCodeFile);
        umlController.updateDiagram(newCodeFile);
    }

    @Override
    public void addNewUmlClass(Class umlClass) {
        CodeFile codeFile = new CodeFile(String.format("%s.java", umlClass.getName()));
        codeFileList.add(codeFile);
        codeFile.addUmlClass(umlClass);
        umlController.updateDiagram(codeFile);
        codeController.updateCodeTab(codeFile);
    }

    @Override
    public void updateCodeFile(ICodeFile changedCodeFile, String code) {
        try {
            ((CodeFile) changedCodeFile).updateCode(code);
            umlController.updateDiagram((CodeFile) changedCodeFile);
        } catch (Exception e) {
            return;
        }
    }

    @Override
    public void addAttribute(String className, Attribute attribute) {
        Optional<Class> targetClass = findClass(className);
        Optional<CodeFile> targetCodeFile = findCodeFile(className + ".java");
        if (targetClass.isEmpty() || targetCodeFile.isEmpty()) {
            return;
        }

        try {
            FieldDeclaration fieldDeclaration = translator.translateAttribute(attribute);
            NodeList<BodyDeclaration<?>> members = targetCodeFile.get().getCompilationUnit().getClassByName(className)
                    .get().getMembers();
            if (members.size() == 0) {
                members.addFirst(fieldDeclaration);
            } else {
                for (int i = 0; i < members.size(); i++) {
                    if (members.get(i).isMethodDeclaration()) {
                        members.addBefore(fieldDeclaration, members.get(i));
                        break;
                    } else if (i == members.size() - 1) {
                        members.addLast(fieldDeclaration);
                        break;
                    }
                }
            }
            targetClass.get().addAttribute(attribute);
            umlController.updateDiagram(targetCodeFile.get());
            codeController.updateCodeTab(targetCodeFile.get());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    @Override
    public void addOperation(String className, Operation operation) {
        Optional<Class> targetClass = findClass(className);
        Optional<CodeFile> targetCodeFile = findCodeFile(className + ".java");
        if (targetClass.isEmpty() || targetCodeFile.isEmpty()) {
            return;
        }

        try {
            targetCodeFile.get().getCompilationUnit().getClassByName(className).get()
                    .addMember(translator.translateOperation(operation));
            targetClass.get().addOperation(operation);
            umlController.updateDiagram(targetCodeFile.get());
            codeController.updateCodeTab(targetCodeFile.get());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    @Override
    public void addComposition(String haveClassName, String compositedClassName) {
        Optional<CodeFile> haveCodefileOptional = findCodeFile(haveClassName + ".java");
        Optional<CodeFile> compositedCodefileOptional = findCodeFile(compositedClassName + ".java");
        Optional<Class> haveClassOptional = findClass(haveClassName);
        Optional<Class> compositedClassOptional = findClass(compositedClassName);

        if (haveCodefileOptional.isEmpty() || compositedCodefileOptional.isEmpty() || haveClassOptional.isEmpty()
                || compositedClassOptional.isEmpty()) {
            return;
        }

        try {
            Name name = new Name(compositedClassName.toLowerCase());
            Attribute attribute = new Attribute(name);
            attribute.setVisibility(Visibility.Private);
            attribute.setType(new Type(compositedClassName));
            addAttribute(haveClassName, attribute);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    @Override
    public void addGeneralization(String generalizedClassName, String superClassName) {
        Optional<CodeFile> generalizedCodefileOptional = findCodeFile(generalizedClassName + ".java");
        Optional<CodeFile> superCodefileOptional = findCodeFile(superClassName + ".java");
        Optional<Class> generalizedClassOptional = findClass(generalizedClassName);
        Optional<Class> superClassOptional = findClass(superClassName);

        if (generalizedCodefileOptional.isEmpty() || superCodefileOptional.isEmpty()
                || generalizedClassOptional.isEmpty() || superClassOptional.isEmpty()) {
            return;
        }

        try {
            CodeFile generalizedCodeFile = generalizedCodefileOptional.get();
            NodeList<ClassOrInterfaceType> extendedTypes = new NodeList<>();
            ClassOrInterfaceType extendedType = new ClassOrInterfaceType();
            extendedType.setName(superClassName);
            extendedTypes.add(extendedType);
            generalizedCodeFile.getCompilationUnit().getClassByName(generalizedClassName).get()
                    .setExtendedTypes(extendedTypes);
            generalizedClassOptional.get().setSuperClass(superClassOptional.get());
            umlController.updateDiagram(generalizedCodefileOptional.get());
            codeController.updateCodeTab(generalizedCodefileOptional.get());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    @Override
    public void delete(String className) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }

        codeFileOptional.get().removeClass(classOptional.get());
        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    @Override
    public void delete(String className, Attribute attribute) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }

        classOptional.get().removeAttribute(attribute);
        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get()
                .getCompilationUnit().getClassByName(className);
        Optional<FieldDeclaration> fieldOptional = classOrInterfaceDeclarationOptional.get()
                .getFieldByName(attribute.getName().getNameText());
        classOrInterfaceDeclarationOptional.get().remove(fieldOptional.get());

        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    @Override
    public void delete(String className, Operation operation) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }

        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get()
                .getCompilationUnit().getClassByName(className);
        List<MethodDeclaration> methodList = classOrInterfaceDeclarationOptional.get()
                .getMethodsByName(operation.getName().getNameText());
        if (methodList.size() <= 0) {
            return;
        }

        Optional<MethodDeclaration> targetMethodOptional = findMethodDeclaration(methodList, operation);
        if (targetMethodOptional.isEmpty()) {
            return;
        }

        classOrInterfaceDeclarationOptional.get().remove(targetMethodOptional.get());
        classOptional.get().removeOperation(operation);
        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    @Override
    public void delete(String className, Operation operation, InteractionFragment interactionFragment) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }
        Class targetClass = classOptional.get();
        CodeFile targetFile = codeFileOptional.get();

        Interaction targetInteraction = null;
        for (Interaction interaction : classOptional.get().getInteractionList()) {
            if (interaction.getOperation().equals(operation)) {
                targetInteraction = interaction;
                break;
            }
        }
        if (Objects.isNull(targetInteraction)) {
            return;
        }

        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get()
                .getCompilationUnit().getClassByName(className);
        List<MethodDeclaration> methodList = classOrInterfaceDeclarationOptional.get()
                .getMethodsByName(operation.getName().getNameText());
        if (methodList.size() <= 0) {
            return;
        }

        Optional<MethodDeclaration> targetMethodOptional = findMethodDeclaration(methodList, operation);
        if (targetMethodOptional.isEmpty() || targetMethodOptional.get().getBody().isEmpty()) {
            return;
        }

        Optional<Statement> removeTargetOptional = Optional.empty();
        if (interactionFragment instanceof OccurenceSpecification) {
            removeTargetOptional = ((OccurenceSpecification) interactionFragment).getStatement();
        } else if (interactionFragment instanceof CombinedFragment) {
            removeTargetOptional = ((CombinedFragment) interactionFragment).getStatement();
        } else {
            return;
        }

        if (removeTargetOptional.isEmpty()) {
            return;
        }

        if (!removeTargetOptional.get().remove()) {
            return;
        }
        targetInteraction.deleteInteractionFragment(interactionFragment);
        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    @Override
    public void deleteSuperClass(String className) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty() || classOptional.get().getSuperClass().isEmpty()) {
            return;
        }

        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get()
                .getCompilationUnit().getClassByName(className);
        classOrInterfaceDeclarationOptional.get().getExtendedTypes().remove(0);
        classOptional.get().setSuperClass(null);

        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    @Override
    public void addMessage(String className, Operation operation, Message message) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }
        Class targetClass = classOptional.get();
        CodeFile targetFile = codeFileOptional.get();

        Interaction targetInteraction = null;
        for (Interaction interaction : classOptional.get().getInteractionList()) {
            if (interaction.getOperation().equals(operation)) {
                targetInteraction = interaction;
                break;
            }
        }
        if (Objects.isNull(targetInteraction)) {
            return;
        }

        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get()
                .getCompilationUnit().getClassByName(className);
        List<MethodDeclaration> methodDeclarationList = classOrInterfaceDeclarationOptional.get()
                .getMethodsByName(operation.getName().getNameText());
        Optional<MethodDeclaration> methodDeclarationOptional = findMethodDeclaration(methodDeclarationList, operation);
        if (methodDeclarationOptional.isEmpty()) {
            return;
        }
        MethodDeclaration targetMethodDeclaration = methodDeclarationOptional.get();

        BlockStmt body = targetMethodDeclaration.getBody().orElse(new BlockStmt());

        OccurenceSpecification occurenceSpecification = new OccurenceSpecification(
                new Lifeline("", targetClass.getName()));
        occurenceSpecification.setMessage(message);

        ExpressionStmt expressionStmt = translator.occurenceSpeccificationToExpressionStmt(occurenceSpecification);

        targetInteraction.getInteractionFragmentList().add(occurenceSpecification);
        body.addStatement(expressionStmt);

        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    public Optional<CodeFile> findCodeFile(String fileName) {
        for (CodeFile codeFile : codeFileList) {
            if (codeFile.getFileName().equals(fileName)) {
                return Optional.of(codeFile);
            }
        }
        return Optional.empty();
    }

    @Override
    public void addCombinedFragment(String className, Operation operation, CombinedFragment combinedFragment) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }
        Class targetClass = classOptional.get();
        CodeFile targetFile = codeFileOptional.get();

        // Interactionの探索
        Interaction targetInteraction = null;
        for (Interaction interaction : classOptional.get().getInteractionList()) {
            if (interaction.getOperation().equals(operation)) {
                targetInteraction = interaction;
                break;
            }
        }
        if (Objects.isNull(targetInteraction)) {
            return;
        }

        // operationに対応するmethodDeclarationを取得
        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get()
                .getCompilationUnit().getClassByName(className);
        List<MethodDeclaration> methodDeclarationList = classOrInterfaceDeclarationOptional.get()
                .getMethodsByName(operation.getName().getNameText());
        Optional<MethodDeclaration> methodDeclarationOptional = findMethodDeclaration(methodDeclarationList, operation);
        if (methodDeclarationOptional.isEmpty()) {
            return;
        }
        MethodDeclaration targetMethodDeclaration = methodDeclarationOptional.get();

        // methodDeclarationのBodyを取得
        BlockStmt body = targetMethodDeclaration.getBody().orElse(new BlockStmt());

        // CombinedFragmnetをStatementに変換
        Statement statement = translator.translateCombinedFragment(combinedFragment);
        combinedFragment.setStatement(statement);

        // UMLモデルとコードモデルに追加
        targetInteraction.getInteractionFragmentList().add(combinedFragment);
        body.addStatement(statement);

        // 再描画
        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    /**
     * methodDeclarationListから、Operationと一致するmethodDeclarationを探索する
     *
     * @param methodDeclarationList Javaのメソッド宣言リスト
     * @param operation             UMLの操作
     * @return 一致するメソッド宣言（存在しない場合はEmpty）
     */
    protected Optional<MethodDeclaration> findMethodDeclaration(
            List<MethodDeclaration> methodDeclarationList,
            Operation operation) {
        MethodDeclaration targetMethod = null;

        int operationParameterSize = 0;
        try {
            operationParameterSize = operation.getParameters().size();
        } catch (Exception e) {
        }

        for (MethodDeclaration methodDeclaration : methodDeclarationList) {
            if (methodDeclaration.getParameters().size() != operationParameterSize) {
                // 引数の数が異なる場合
                continue;
            }

            if (operationParameterSize == 0) {
                // 引数の数が同じ、かつ、引数が0の場合
                targetMethod = methodDeclaration;
                break;
            }

            // 引数の数が同じ、かつ、引数が複数ある場合
            int cntSameParameters = 0;
            for (int i = 0; i < methodDeclaration.getParameters().size(); i++) {
                if (!methodDeclaration.getParameters().get(i).getTypeAsString()
                        .equals(operation.getParameters().get(i).getType().toString())) {
                    break;
                }
                cntSameParameters++;
            }
            if (cntSameParameters == methodDeclaration.getParameters().size()) {
                targetMethod = methodDeclaration;
                break;
            }
        }

        return Optional.ofNullable(targetMethod);
    }
}
DEBUG: Updated UML classes: 1
DEBUG: Class: JavaModel
DEBUG: Attributes: 3
DEBUG: Operations: 18
DEBUG: get Java code:
package io.github.morichan.retuss.model;

import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.BodyDeclaration;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.ExpressionStmt;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import io.github.morichan.fescue.feature.Attribute;
import io.github.morichan.fescue.feature.Operation;
import io.github.morichan.fescue.feature.name.Name;
import io.github.morichan.fescue.feature.type.Type;
import io.github.morichan.fescue.feature.visibility.Visibility;
import io.github.morichan.retuss.model.common.AbstractJavaModel;
import io.github.morichan.retuss.model.common.ICodeFile;
import io.github.morichan.retuss.model.uml.Class;
import io.github.morichan.retuss.model.uml.*;
import io.github.morichan.retuss.translator.JavaTranslator;
import java.util.*;

/**
 * <p>
 * Java言語用のモデルクラス
 * </p>
 * <p>
 * Singletonパターンを使用
 * </p>
 */
public class JavaModel extends AbstractJavaModel {

    private static JavaModel model = new JavaModel();

    private List<CodeFile> codeFileList = new ArrayList<>();

    private JavaTranslator translator = new JavaTranslator();

    private JavaModel() {
    }

    public static JavaModel getInstance() {
        return model;
    }

    @Override
    protected List<? extends ICodeFile> getCodeFileList() {
        return Collections.unmodifiableList(codeFileList);
    }

    @Override
    public void addNewCodeFile(String fileName) {
        CodeFile newCodeFile = new CodeFile(fileName);
        codeFileList.add(newCodeFile);
        codeController.updateCodeTab(newCodeFile);
        umlController.updateDiagram(newCodeFile);
    }

    @Override
    public void addNewUmlClass(Class umlClass) {
        CodeFile codeFile = new CodeFile(String.format("%s.java", umlClass.getName()));
        codeFileList.add(codeFile);
        codeFile.addUmlClass(umlClass);
        umlController.updateDiagram(codeFile);
        codeController.updateCodeTab(codeFile);
    }

    @Override
    public void updateCodeFile(ICodeFile changedCodeFile, String code) {
        try {
            ((CodeFile) changedCodeFile).updateCode(code);
            umlController.updateDiagram((CodeFile) changedCodeFile);
        } catch (Exception e) {
            return;
        }
    }

    @Override
    public void addAttribute(String className, Attribute attribute) {
        Optional<Class> targetClass = findClass(className);
        Optional<CodeFile> targetCodeFile = findCodeFile(className + ".java");
        if (targetClass.isEmpty() || targetCodeFile.isEmpty()) {
            return;
        }
        try {
            FieldDeclaration fieldDeclaration = translator.translateAttribute(attribute);
            NodeList<BodyDeclaration<?>> members = targetCodeFile.get().getCompilationUnit().getClassByName(className).get().getMembers();
            if (members.size() == 0) {
                members.addFirst(fieldDeclaration);
            } else {
                for (int i = 0; i < members.size(); i++) {
                    if (members.get(i).isMethodDeclaration()) {
                        members.addBefore(fieldDeclaration, members.get(i));
                        break;
                    } else if (i == members.size() - 1) {
                        members.addLast(fieldDeclaration);
                        break;
                    }
                }
            }
            targetClass.get().addAttribute(attribute);
            umlController.updateDiagram(targetCodeFile.get());
            codeController.updateCodeTab(targetCodeFile.get());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    @Override
    public void addOperation(String className, Operation operation) {
        Optional<Class> targetClass = findClass(className);
        Optional<CodeFile> targetCodeFile = findCodeFile(className + ".java");
        if (targetClass.isEmpty() || targetCodeFile.isEmpty()) {
            return;
        }
        try {
            targetCodeFile.get().getCompilationUnit().getClassByName(className).get().addMember(translator.translateOperation(operation));
            targetClass.get().addOperation(operation);
            umlController.updateDiagram(targetCodeFile.get());
            codeController.updateCodeTab(targetCodeFile.get());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    @Override
    public void addComposition(String haveClassName, String compositedClassName) {
        Optional<CodeFile> haveCodefileOptional = findCodeFile(haveClassName + ".java");
        Optional<CodeFile> compositedCodefileOptional = findCodeFile(compositedClassName + ".java");
        Optional<Class> haveClassOptional = findClass(haveClassName);
        Optional<Class> compositedClassOptional = findClass(compositedClassName);
        if (haveCodefileOptional.isEmpty() || compositedCodefileOptional.isEmpty() || haveClassOptional.isEmpty() || compositedClassOptional.isEmpty()) {
            return;
        }
        try {
            Name name = new Name(compositedClassName.toLowerCase());
            Attribute attribute = new Attribute(name);
            attribute.setVisibility(Visibility.Private);
            attribute.setType(new Type(compositedClassName));
            addAttribute(haveClassName, attribute);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    @Override
    public void addGeneralization(String generalizedClassName, String superClassName) {
        Optional<CodeFile> generalizedCodefileOptional = findCodeFile(generalizedClassName + ".java");
        Optional<CodeFile> superCodefileOptional = findCodeFile(superClassName + ".java");
        Optional<Class> generalizedClassOptional = findClass(generalizedClassName);
        Optional<Class> superClassOptional = findClass(superClassName);
        if (generalizedCodefileOptional.isEmpty() || superCodefileOptional.isEmpty() || generalizedClassOptional.isEmpty() || superClassOptional.isEmpty()) {
            return;
        }
        try {
            CodeFile generalizedCodeFile = generalizedCodefileOptional.get();
            NodeList<ClassOrInterfaceType> extendedTypes = new NodeList<>();
            ClassOrInterfaceType extendedType = new ClassOrInterfaceType();
            extendedType.setName(superClassName);
            extendedTypes.add(extendedType);
            generalizedCodeFile.getCompilationUnit().getClassByName(generalizedClassName).get().setExtendedTypes(extendedTypes);
            generalizedClassOptional.get().setSuperClass(superClassOptional.get());
            umlController.updateDiagram(generalizedCodefileOptional.get());
            codeController.updateCodeTab(generalizedCodefileOptional.get());
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    @Override
    public void delete(String className) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }
        codeFileOptional.get().removeClass(classOptional.get());
        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    @Override
    public void delete(String className, Attribute attribute) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }
        classOptional.get().removeAttribute(attribute);
        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get().getCompilationUnit().getClassByName(className);
        Optional<FieldDeclaration> fieldOptional = classOrInterfaceDeclarationOptional.get().getFieldByName(attribute.getName().getNameText());
        classOrInterfaceDeclarationOptional.get().remove(fieldOptional.get());
        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    @Override
    public void delete(String className, Operation operation) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }
        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get().getCompilationUnit().getClassByName(className);
        List<MethodDeclaration> methodList = classOrInterfaceDeclarationOptional.get().getMethodsByName(operation.getName().getNameText());
        if (methodList.size() <= 0) {
            return;
        }
        Optional<MethodDeclaration> targetMethodOptional = findMethodDeclaration(methodList, operation);
        if (targetMethodOptional.isEmpty()) {
            return;
        }
        classOrInterfaceDeclarationOptional.get().remove(targetMethodOptional.get());
        classOptional.get().removeOperation(operation);
        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    @Override
    public void delete(String className, Operation operation, InteractionFragment interactionFragment) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }
        Class targetClass = classOptional.get();
        CodeFile targetFile = codeFileOptional.get();
        Interaction targetInteraction = null;
        for (Interaction interaction : classOptional.get().getInteractionList()) {
            if (interaction.getOperation().equals(operation)) {
                targetInteraction = interaction;
                break;
            }
        }
        if (Objects.isNull(targetInteraction)) {
            return;
        }
        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get().getCompilationUnit().getClassByName(className);
        List<MethodDeclaration> methodList = classOrInterfaceDeclarationOptional.get().getMethodsByName(operation.getName().getNameText());
        if (methodList.size() <= 0) {
            return;
        }
        Optional<MethodDeclaration> targetMethodOptional = findMethodDeclaration(methodList, operation);
        if (targetMethodOptional.isEmpty() || targetMethodOptional.get().getBody().isEmpty()) {
            return;
        }
        Optional<Statement> removeTargetOptional = Optional.empty();
        if (interactionFragment instanceof OccurenceSpecification) {
            removeTargetOptional = ((OccurenceSpecification) interactionFragment).getStatement();
        } else if (interactionFragment instanceof CombinedFragment) {
            removeTargetOptional = ((CombinedFragment) interactionFragment).getStatement();
        } else {
            return;
        }
        if (removeTargetOptional.isEmpty()) {
            return;
        }
        if (!removeTargetOptional.get().remove()) {
            return;
        }
        targetInteraction.deleteInteractionFragment(interactionFragment);
        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    @Override
    public void deleteSuperClass(String className) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty() || classOptional.get().getSuperClass().isEmpty()) {
            return;
        }
        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get().getCompilationUnit().getClassByName(className);
        classOrInterfaceDeclarationOptional.get().getExtendedTypes().remove(0);
        classOptional.get().setSuperClass(null);
        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    @Override
    public void addMessage(String className, Operation operation, Message message) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }
        Class targetClass = classOptional.get();
        CodeFile targetFile = codeFileOptional.get();
        Interaction targetInteraction = null;
        for (Interaction interaction : classOptional.get().getInteractionList()) {
            if (interaction.getOperation().equals(operation)) {
                targetInteraction = interaction;
                break;
            }
        }
        if (Objects.isNull(targetInteraction)) {
            return;
        }
        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get().getCompilationUnit().getClassByName(className);
        List<MethodDeclaration> methodDeclarationList = classOrInterfaceDeclarationOptional.get().getMethodsByName(operation.getName().getNameText());
        Optional<MethodDeclaration> methodDeclarationOptional = findMethodDeclaration(methodDeclarationList, operation);
        if (methodDeclarationOptional.isEmpty()) {
            return;
        }
        MethodDeclaration targetMethodDeclaration = methodDeclarationOptional.get();
        BlockStmt body = targetMethodDeclaration.getBody().orElse(new BlockStmt());
        OccurenceSpecification occurenceSpecification = new OccurenceSpecification(new Lifeline("", targetClass.getName()));
        occurenceSpecification.setMessage(message);
        ExpressionStmt expressionStmt = translator.occurenceSpeccificationToExpressionStmt(occurenceSpecification);
        targetInteraction.getInteractionFragmentList().add(occurenceSpecification);
        body.addStatement(expressionStmt);
        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    public Optional<CodeFile> findCodeFile(String fileName) {
        for (CodeFile codeFile : codeFileList) {
            if (codeFile.getFileName().equals(fileName)) {
                return Optional.of(codeFile);
            }
        }
        return Optional.empty();
    }

    @Override
    public void addCombinedFragment(String className, Operation operation, CombinedFragment combinedFragment) {
        Optional<Class> classOptional = findClass(className);
        Optional<CodeFile> codeFileOptional = findCodeFile(className + ".java");
        if (classOptional.isEmpty() || codeFileOptional.isEmpty()) {
            return;
        }
        Class targetClass = classOptional.get();
        CodeFile targetFile = codeFileOptional.get();
        // Interactionの探索
        Interaction targetInteraction = null;
        for (Interaction interaction : classOptional.get().getInteractionList()) {
            if (interaction.getOperation().equals(operation)) {
                targetInteraction = interaction;
                break;
            }
        }
        if (Objects.isNull(targetInteraction)) {
            return;
        }
        // operationに対応するmethodDeclarationを取得
        Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclarationOptional = codeFileOptional.get().getCompilationUnit().getClassByName(className);
        List<MethodDeclaration> methodDeclarationList = classOrInterfaceDeclarationOptional.get().getMethodsByName(operation.getName().getNameText());
        Optional<MethodDeclaration> methodDeclarationOptional = findMethodDeclaration(methodDeclarationList, operation);
        if (methodDeclarationOptional.isEmpty()) {
            return;
        }
        MethodDeclaration targetMethodDeclaration = methodDeclarationOptional.get();
        // methodDeclarationのBodyを取得
        BlockStmt body = targetMethodDeclaration.getBody().orElse(new BlockStmt());
        // CombinedFragmnetをStatementに変換
        Statement statement = translator.translateCombinedFragment(combinedFragment);
        combinedFragment.setStatement(statement);
        // UMLモデルとコードモデルに追加
        targetInteraction.getInteractionFragmentList().add(combinedFragment);
        body.addStatement(statement);
        // 再描画
        umlController.updateDiagram(codeFileOptional.get());
        codeController.updateCodeTab(codeFileOptional.get());
    }

    /**
     * methodDeclarationListから、Operationと一致するmethodDeclarationを探索する
     *
     * @param methodDeclarationList Javaのメソッド宣言リスト
     * @param operation             UMLの操作
     * @return 一致するメソッド宣言（存在しない場合はEmpty）
     */
    protected Optional<MethodDeclaration> findMethodDeclaration(List<MethodDeclaration> methodDeclarationList, Operation operation) {
        MethodDeclaration targetMethod = null;
        int operationParameterSize = 0;
        try {
            operationParameterSize = operation.getParameters().size();
        } catch (Exception e) {
        }
        for (MethodDeclaration methodDeclaration : methodDeclarationList) {
            if (methodDeclaration.getParameters().size() != operationParameterSize) {
                // 引数の数が異なる場合
                continue;
            }
            if (operationParameterSize == 0) {
                // 引数の数が同じ、かつ、引数が0の場合
                targetMethod = methodDeclaration;
                break;
            }
            // 引数の数が同じ、かつ、引数が複数ある場合
            int cntSameParameters = 0;
            for (int i = 0; i < methodDeclaration.getParameters().size(); i++) {
                if (!methodDeclaration.getParameters().get(i).getTypeAsString().equals(operation.getParameters().get(i).getType().toString())) {
                    break;
                }
                cntSameParameters++;
            }
            if (cntSameParameters == methodDeclaration.getParameters().size()) {
                targetMethod = methodDeclaration;
                break;
            }
        }
        return Optional.ofNullable(targetMethod);
    }
}

DEBUG: Updating diagram for file: JavaModel.java
DEBUG: Updating Java diagrams
DEBUG: Java diagrams update completed
DEBUG: Updating Java code:
package io.github.morichan.retuss.model;

import io.github.morichan.fescue.feature.Attribute;
import io.github.morichan.fescue.feature.Operation;
import io.github.morichan.fescue.feature.parameter.Parameter;
import io.github.morichan.fescue.feature.visibility.Visibility;
import io.github.morichan.retuss.controller.CodeController;
import io.github.morichan.retuss.controller.UmlController;
import io.github.morichan.retuss.model.uml.cpp.*;
import io.github.morichan.retuss.model.uml.cpp.utils.*;
import io.github.morichan.retuss.translator.cpp.CppTranslator;

import java.util.*;

import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

public class CppModel {
    private final UmlModel umlModel;
    private static final CppModel model = new CppModel();
    private final Map<String, CppFile> headerFiles = new HashMap<>();
    private final Map<String, CppFile> implFiles = new HashMap<>();
    private final CppTranslator translator;
    private CodeController codeController;
    private UmlController umlController;
    private final List<ModelChangeListener> changeListeners = new ArrayList<>();

    private CppModel() {
        this.umlModel = UmlModel.getInstance();
        this.translator = createTranslator();
    }

    private CppTranslator createTranslator() {
        return new CppTranslator();
    }

    public static CppModel getInstance() {
        return model;
    }

    public void setCodeController(CodeController controller) {
        this.codeController = controller;
    }

    public void setUmlController(UmlController controller) {
        this.umlController = controller;
        for (CppFile file : headerFiles.values()) {
            file.setUmlController(controller);
        }
        for (CppFile file : implFiles.values()) {
            file.setUmlController(controller);
        }
    }

    public void addNewFile(String fileName) {
        String baseName = fileName.replaceAll("\\.(h|hpp|cpp)$", "");
        if (!headerFiles.containsKey(baseName)) {
            createCppFiles(baseName, Optional.empty());
        }
    }

    public void addNewFileFromUml(CppHeaderClass headerClass) {
        createCppFiles(headerClass.getName(), Optional.of(headerClass));
    }

    private void createCppFiles(String baseName, Optional<CppHeaderClass> headerClass) {
        if (headerFiles.containsKey(baseName)) {
            System.out.println("Files already exist for baseName: " + baseName);
            return;
        }
        // ヘッダーファイル作成
        CppFile headerFile = new CppFile(baseName + ".h", true);
        if (headerClass.isPresent()) {
            String headerCode = headerFile.getCode();
            headerFile.updateCode(headerCode);
        }

        CppFile implFile = new CppFile(baseName + ".cpp", false);

        if (umlController != null) {
            headerFile.setUmlController(umlController);
            implFile.setUmlController(umlController);
        }

        headerFile.addChangeListener(new CppFile.FileChangeListener() {
            @Override
            public void onFileChanged(CppFile file) {
                updateImplFileForHeaderChange(file);
                notifyModelChanged();
            }

            @Override
            public void onFileNameChanged(String oldName, String newName) {
                String oldBaseName = oldName.replace(".h", "");
                String newBaseName = newName.replace(".h", "");

                // ヘッダーファイル更新
                String headerCode = headerFile.getCode();
                headerCode = headerCode
                        .replace(oldBaseName.toUpperCase() + "_H", newBaseName.toUpperCase() + "_H")
                        .replaceAll("(?<![a-zA-Z0-9_])" + oldBaseName + "(\\s*\\([^)]*\\)\\s*;)", newBaseName + "$1")
                        .replaceAll("(?<![a-zA-Z0-9_])~" + oldBaseName + "(\\s*\\([^)]*\\)\\s*;)",
                                "~" + newBaseName + "$1");
                headerFile.updateCode(headerCode);

                CppFile implFile = implFiles.get(oldBaseName);
                if (implFile != null) {
                    implFile.updateFileName(newBaseName + ".cpp");

                    String implCode = implFile.getCode();
                    implCode = implCode
                            .replace("#include \"" + oldName + "\"", "#include \"" + newName + "\"")
                            .replace(oldBaseName + "::", newBaseName + "::")
                            .replaceAll("(?<![a-zA-Z0-9_])" + oldBaseName + "(\\s*\\([^)]*\\)\\s*\\{)",
                                    newBaseName + "$1")
                            .replaceAll("(?<![a-zA-Z0-9_])~" + oldBaseName + "(\\s*\\([^)]*\\)\\s*\\{)",
                                    "~" + newBaseName + "$1");

                    implFile.updateCode(implCode);
                }
            }
        });

        headerFiles.put(baseName, headerFile);
        implFiles.put(baseName, implFile);

        if (codeController != null) {
            codeController.updateCodeTab(headerFile);
            codeController.updateCodeTab(implFile);
        }
        if (umlController != null) {
            umlController.updateDiagram(headerFile);
        }
    }

    public void updateCode(CppFile file, String code) {
        String baseName = file.getBaseName();

        if (file.isHeader()) {
            updateHeaderFile(file, code, baseName);
            // // 図の更新をトリガー
            if (umlController != null) {
                umlController.updateDiagram(file);
            }
        } else {
            // updateImplementationFile(file, code);
            // CppFile headerFile = headerFiles.get(baseName);
            // if (headerFile != null && !headerFile.getHeaderClasses().isEmpty()) {
            // // analyzeImplementationRelationships(headerFile, file);
            // // 図の更新をトリガー
            // if (umlController != null) {
            // umlController.updateDiagram(headerFile);
            // }
            // }
        }

        notifyModelChanged();
    }

    private void updateHeaderFile(CppFile headerFile, String code, String baseName) {
        System.out.println("DEBUG: Updating header file");
        System.out.println("DEBUG: Current classes before update: " + headerFiles.size());
        // 古いクラス名を保存
        String oldClassName = headerFile.getFileName().replace(".h", "");

        // コードを更新
        headerFile.updateCode(code);

        List<CppHeaderClass> classes = headerFile.getHeaderClasses();
        System.out.println("DEBUG: Classes after parsing: " + (classes != null ? classes.size() : "null"));
        for (CppHeaderClass cls : classes) {
            System.out.println("DEBUG: Class: " + cls.getName());
            System.out.println("DEBUG: Operations: " + cls.getOperationList().size());
        }

        // 新しいクラス名を取得
        Optional<String> newClassName = translator.extractClassName(code);
        if (newClassName.isPresent()) {
            String newName = newClassName.get();
            System.out.println("DEBUG: Class name change detected: " + oldClassName +
                    " -> " + newName);

            if (!newName.equals(oldClassName)) {
                // マップの更新
                headerFiles.remove(oldClassName);
                headerFiles.put(newName, headerFile);

                // 実装ファイルの更新
                updateImplFileForClassNameChange(oldClassName, newName);

                System.out.println("DEBUG: 実装ファイル更新あと！");

                // コントローラーに通知（既存の処理を維持）
                if (codeController != null) {
                    codeController.updateCodeTab(headerFile);
                }
            }
        }
        // // 実装ファイルの関係解析
        // CppFile implFile = implFiles.get(baseName);
        // if (implFile != null) {
        // analyzeImplementationRelationships(headerFile, implFile);
        // }
    }

    private void updateImplFileForClassNameChange(String oldClassName, String newClassName) {
        CppFile implFile = implFiles.remove(oldClassName);
        if (implFile != null) {
            String newImplName = newClassName + ".cpp";
            String oldImplName = implFile.getFileName();

            // ヘッダーファイルのインクルードを更新
            String currentCode = implFile.getCode();
            String oldInclude = "#include \"" + oldClassName + ".h\"";
            String newInclude = "#include \"" + newClassName + ".h\"";
            String newCode = currentCode.replace(oldInclude, newInclude);

            // ファイル名と内容を更新
            implFile.updateFileName(newImplName);
            implFile.updateCode(newCode);
            implFiles.put(newClassName, implFile);

            // コントローラーに通知
            if (codeController != null) {
                codeController.updateCodeTab(implFile);
            }

            System.out.println("DEBUG: Updated implementation file name from " +
                    oldImplName + " to " + newImplName);
        }
    }

    private void updateImplementationFile(CppFile implFile, String code) {
        String baseName = implFile.getBaseName();
        CppFile headerFile = headerFiles.get(baseName);

        implFile.updateCode(code);

        // ヘッダーファイルが存在する場合は関係を解析
        if (headerFile != null && !headerFile.getHeaderClasses().isEmpty()) {
            // analyzeImplementationRelationships(headerFile, implFile);
        }

        // 既存の通知処理を維持
        if (codeController != null) {
            codeController.updateCodeTab(implFile);
        }
    }

    // private void analyzeImplementationRelationships(CppFile headerFile, CppFile
    // implFile) {
    // if (!headerFile.getHeaderClasses().isEmpty()) {
    // Class umlClass = headerFile.getUmlClassList().get(0);
    // try {
    // CharStream input = CharStreams.fromString(implFile.getCode());
    // CPP14Lexer lexer = new CPP14Lexer(input);
    // CommonTokenStream tokens = new CommonTokenStream(lexer);
    // CPP14Parser parser = new CPP14Parser(tokens);

    // CppMethodAnalyzer analyzer = new CppMethodAnalyzer(umlClass);
    // ParseTreeWalker walker = new ParseTreeWalker();
    // walker.walk(analyzer, parser.translationUnit());

    // System.out.println("DEBUG: Analyzed implementation relationships for " +
    // implFile.getFileName());
    // } catch (Exception e) {
    // System.err.println("Error analyzing implementation relationships: " +
    // e.getMessage());
    // }
    // }
    // }

    public void addAttribute(String className, Attribute attribute) {
        Optional<CppFile> headerFileOpt = findHeaderFileByClassName(className);
        if (headerFileOpt.isEmpty())
            return;

        CppFile headerFile = headerFileOpt.get();
        try {
            if (!headerFile.getHeaderClasses().isEmpty()) {
                CppHeaderClass targetClass = headerFile.getHeaderClasses().get(0);

                String currentCode = headerFile.getCode();
                String newCode = translator.addAttribute(currentCode, targetClass, attribute);
                headerFile.updateCode(newCode);

                if (umlController != null) {
                    umlController.updateDiagram(headerFile);
                }
            }
        } catch (Exception e) {
            System.err.println("Failed to add attribute: " + e.getMessage());
        }
    }

    public void addOperation(String className, Operation operation) {
        Optional<CppFile> headerFileOpt = findHeaderFileByClassName(className);
        if (headerFileOpt.isEmpty())
            return;

        try {
            CppFile headerFile = headerFileOpt.get();
            CppHeaderClass targetClass = headerFile.getHeaderClasses().get(0);

            String currentCode = headerFile.getCode();
            String newCode = translator.addOperation(currentCode, targetClass, operation);
            headerFile.updateCode(newCode);
            notifyModelChanged();
        } catch (Exception e) {
            System.err.println("Failed to add operation: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void delete(String className) {
        System.out.println("Attempting to delete class: " + className);

        Optional<CppFile> headerFileOpt = findHeaderFileByClassName(className);
        if (headerFileOpt.isEmpty()) {
            System.out.println("Header file not found for class: " + className);
            return;
        }

        try {
            System.out.println("Found header file, proceeding with deletion");
            CppFile headerFile = headerFileOpt.get();

            // ヘッダーファイルのクラスリストをチェック
            System.out.println("Header classes count: " + headerFile.getHeaderClasses().size());

            if (!headerFile.getHeaderClasses().isEmpty()) {
                System.out.println("Removing class from header file");
                headerFile.removeClass(headerFile.getHeaderClasses().get(0));
            }

            // 実装ファイルの削除
            CppFile implFile = findImplFile(className);
            if (implFile != null) {
                System.out.println("Removing implementation file");
                implFiles.remove(className);
            }

            // ヘッダーファイルの削除
            System.out.println("Removing header file");
            headerFiles.remove(className);

            // コントローラーへの通知
            if (umlController != null) {
                System.out.println("Notifying UML controller");
                umlController.onClassDeleted(className);
            }
            if (codeController != null) {
                System.out.println("Notifying code controller");
                codeController.onClassDeleted(className);
            }

            System.out.println("Notifying model change");
            notifyModelChanged();

        } catch (Exception e) {
            System.err.println("Error during class deletion:");
            System.err.println("Error type: " + e.getClass().getName());
            System.err.println("Error message: " + e.getMessage());
            e.printStackTrace();
            throw e; // エラーを再スローして上位で処理できるようにする
        }
    }

    public void delete(String className, Attribute attribute) {
        Optional<CppFile> headerFileOpt = findHeaderFileByClassName(className);
        if (headerFileOpt.isEmpty()) {
            System.out.println("Header file not found for class: " + className);
            return;
        }

        try {
            CppFile headerFile = headerFileOpt.get();
            CppHeaderClass targetClass = headerFile.getHeaderClasses().get(0);

            System.out.println("Attempting to delete attribute: " + attribute.getName().getNameText() + " from class: "
                    + className);

            // コードから属性を削除
            String currentCode = headerFile.getCode();
            List<String> lines = new ArrayList<>(Arrays.asList(currentCode.split("\n")));
            String attrName = attribute.getName().getNameText();

            for (int i = 0; i < lines.size(); i++) {
                String line = lines.get(i).trim();
                if (line.contains(attrName) && line.endsWith(";") && !line.contains("(")) {
                    lines.remove(i);
                    if (i > 0 && lines.get(i - 1).trim().startsWith("//")) {
                        // 関連するコメント（アノテーション）も削除
                        lines.remove(i - 1);
                    }
                    break;
                }
            }

            headerFile.updateCode(String.join("\n", lines));
        } catch (Exception e) {
            System.err.println("Failed to delete attribute: " + e.getMessage());
        }
    }

    public void delete(String className, Operation operation) {
        Optional<CppFile> headerFileOpt = findHeaderFileByClassName(className);
        if (headerFileOpt.isEmpty()) {
            System.out.println("Header file not found for class: " + className);
            return;
        }

        try {
            CppFile headerFile = headerFileOpt.get();
            CppHeaderClass targetClass = headerFile.getHeaderClasses().get(0);

            System.out.println("Attempting to delete operation: " + operation.getName().getNameText() + " from class: "
                    + className);

            // コードから操作を削除
            String currentCode = headerFile.getCode();
            List<String> lines = new ArrayList<>(Arrays.asList(currentCode.split("\n")));
            String opName = operation.getName().getNameText();

            for (int i = 0; i < lines.size(); i++) {
                String line = lines.get(i).trim();
                if (line.contains(opName) && line.contains("(") && line.endsWith(";")) {
                    lines.remove(i);
                    break;
                }
            }

            headerFile.updateCode(String.join("\n", lines));
        } catch (Exception e) {
            System.err.println("Failed to delete operation: " + e.getMessage());
        }
    }

    public void addInheritance(String derivedClassName, String baseClassName) {
        Optional<CppFile> derivedFileOpt = findHeaderFileByClassName(derivedClassName);
        Optional<CppFile> baseFileOpt = findHeaderFileByClassName(baseClassName);

        if (derivedFileOpt.isEmpty() || baseFileOpt.isEmpty())
            return;

        try {
            CppFile derivedFile = derivedFileOpt.get();
            CppHeaderClass derivedClass = derivedFile.getHeaderClasses().get(0);
            CppHeaderClass baseClass = baseFileOpt.get().getHeaderClasses().get(0);

            // derivedClass.setSuperClass(baseClass);
            String newCode = translator.addInheritance(derivedFile.getCode(), derivedClassName, baseClassName);
            derivedFile.updateCode(newCode);
        } catch (Exception e) {
            System.err.println("Failed to add inheritance: " + e.getMessage());
        }
    }

    private int findClassEndPosition(List<String> lines) {
        // 後ろから検索してクラスの終了位置を見つける
        for (int i = lines.size() - 1; i >= 0; i--) {
            if (lines.get(i).trim().equals("};")) {
                return i;
            }
        }
        return lines.size() - 1;
    }

    public void addRealization(String sourceClassName, String interfaceName) {
        Optional<CppFile> sourceFileOpt = findHeaderFileByClassName(sourceClassName);
        Optional<CppFile> interfaceFileOpt = findHeaderFileByClassName(interfaceName);

        if (sourceFileOpt.isEmpty() || interfaceFileOpt.isEmpty())
            return;

        try {
            CppFile sourceFile = sourceFileOpt.get();
            CppHeaderClass sourceClass = sourceFile.getHeaderClasses().get(0);
            CppHeaderClass interfaceClass = interfaceFileOpt.get().getHeaderClasses().get(0);

            String newCode = translator.addInheritance(
                    sourceFile.getCode(), sourceClassName,
                    interfaceName);

            List<String> lines = new ArrayList<>(Arrays.asList(newCode.split("\n")));
            int classStart = -1;
            int classEnd = findClassEndPosition(lines);

            for (int i = 0; i < lines.size(); i++) {
                if (lines.get(i).contains("class " + sourceClassName)) {
                    classStart = i;
                    break;
                }
            }

            for (Operation op : interfaceClass.getOperationList()) {
                // 重複チェック
                if (isDuplicateMethod(op, lines, classStart, classEnd)) {
                    System.out.println("Skipping duplicate method: " + op.getName().getNameText());
                    continue;
                }

                Operation implementedOp = new Operation(op.getName());
                implementedOp.setReturnType(op.getReturnType());
                implementedOp.setVisibility(Visibility.Public);
                implementedOp.setParameters(new ArrayList<>()); // 空のパラメータリストで初期化

                // 安全にパラメータを取得してコピー
                List<Parameter> params = safeGetParameters(op);
                for (Parameter param : params) {
                    implementedOp.addParameter(param);
                }

                System.out.println("Adding method: " + implementedOp.getName().getNameText());
                sourceClass.addMemberModifier(implementedOp.getName().getNameText(), Modifier.OVERRIDE);
                newCode = translator.addOperation(newCode, sourceClass, implementedOp);
            }

            // sourceClass.getRelationshipManager().addRealization(interfaceName);
            sourceFile.updateCode(newCode);

            if (umlController != null) {
                umlController.updateDiagram(sourceFile);
            }
        } catch (Exception e) {
            System.err.println("Failed to add realization: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private List<Parameter> safeGetParameters(Operation op) {
        try {
            return op.getParameters() != null ? op.getParameters() : new ArrayList<>();
        } catch (IllegalStateException e) {
            System.out.println("No parameters initialized for method: " + op.getName().getNameText());
            return new ArrayList<>();
        }
    }

    public void addComposition(String ownerClassName, String componentClassName, Visibility visibility) {
        Optional<CppFile> ownerFileOpt = findHeaderFileByClassName(ownerClassName);
        if (ownerFileOpt.isEmpty())
            return;

        try {
            CppFile ownerFile = ownerFileOpt.get();
            CppHeaderClass ownerClass = ownerFile.getHeaderClasses().get(0);

            String memberName = componentClassName.toLowerCase();
            String newCode = translator.addComposition(
                    ownerFile.getCode(),
                    componentClassName,
                    memberName,
                    visibility);

            ownerClass.getRelationshipManager().addComposition(
                    componentClassName,
                    memberName,
                    "1",
                    visibility);

            ownerFile.updateCode(newCode);
            if (umlController != null) {
                umlController.updateDiagram(ownerFile);
            }
        } catch (Exception e) {
            System.err.println("Failed to add composition: " + e.getMessage());
        }
    }

    public void addCompositionWithAnnotation(String ownerClassName, String componentClassName, Visibility visibility) {
        Optional<CppFile> ownerFileOpt = findHeaderFileByClassName(ownerClassName);
        if (ownerFileOpt.isEmpty())
            return;

        try {
            CppFile ownerFile = ownerFileOpt.get();
            CppHeaderClass ownerClass = ownerFile.getHeaderClasses().get(0);

            String memberName = componentClassName.toLowerCase() + "Ptr";
            String newCode = translator.addCompositionWithAnnotation(
                    ownerFile.getCode(),
                    componentClassName,
                    memberName,
                    visibility);

            ownerClass.getRelationshipManager().addComposition(
                    componentClassName,
                    memberName,
                    "1",
                    visibility);

            ownerFile.updateCode(newCode);
            if (umlController != null) {
                umlController.updateDiagram(ownerFile);
            }
        } catch (Exception e) {
            System.err.println("Failed to add annotated composition: " + e.getMessage());
        }
    }

    public void addAggregation(String ownerClassName, String componentClassName, Visibility visibility) {
        Optional<CppFile> ownerFileOpt = findHeaderFileByClassName(ownerClassName);
        if (ownerFileOpt.isEmpty())
            return;

        try {
            CppFile ownerFile = ownerFileOpt.get();
            CppHeaderClass ownerClass = ownerFile.getHeaderClasses().get(0);

            String memberName = componentClassName.toLowerCase() + "Ptr";
            String newCode = translator.addAggregation(
                    ownerFile.getCode(),
                    componentClassName,
                    memberName,
                    visibility);

            ownerClass.getRelationshipManager().addAggregation(
                    componentClassName,
                    memberName,
                    "1",
                    visibility);

            ownerFile.updateCode(newCode);
            if (umlController != null) {
                umlController.updateDiagram(ownerFile);
            }
        } catch (Exception e) {
            System.err.println("Failed to add aggregation: " + e.getMessage());
        }
    }

    public void addAggregationWithAnnotation(String ownerClassName, String componentClassName, Visibility visibility) {
        Optional<CppFile> ownerFileOpt = findHeaderFileByClassName(ownerClassName);
        if (ownerFileOpt.isEmpty())
            return;

        try {
            CppFile ownerFile = ownerFileOpt.get();
            CppHeaderClass ownerClass = ownerFile.getHeaderClasses().get(0);

            String memberName = componentClassName.toLowerCase() + "Ptr";
            String newCode = translator.addAggregationWithAnnotation(
                    ownerFile.getCode(),
                    componentClassName,
                    memberName,
                    visibility);

            ownerClass.getRelationshipManager().addAggregation(
                    componentClassName,
                    memberName,
                    "1",
                    visibility);

            ownerFile.updateCode(newCode);
            if (umlController != null) {
                umlController.updateDiagram(ownerFile);
            }
        } catch (Exception e) {
            System.err.println("Failed to add annotated aggregation: " + e.getMessage());
        }
    }

    public void addAssociation(String sourceClassName, String targetClassName, Visibility visibility) {
        Optional<CppFile> sourceFileOpt = findHeaderFileByClassName(sourceClassName);
        if (sourceFileOpt.isEmpty())
            return;

        try {
            CppFile sourceFile = sourceFileOpt.get();
            CppHeaderClass sourceClass = sourceFile.getHeaderClasses().get(0);

            String memberName = targetClassName.toLowerCase() + "Ptr";
            String newCode = translator.addAssociation(
                    sourceFile.getCode(),
                    targetClassName,
                    memberName,
                    visibility);

            sourceClass.getRelationshipManager().addAssociation(
                    targetClassName,
                    memberName,
                    "1",
                    visibility);

            sourceFile.updateCode(newCode);
            if (umlController != null) {
                umlController.updateDiagram(sourceFile);
            }
        } catch (Exception e) {
            System.err.println("Failed to add association: " + e.getMessage());
        }
    }

    private boolean isDuplicateMethod(Operation newOp, List<String> lines, int startLine, int endLine) {
        // メソッドのシグネチャを作成
        String signature = getMethodSignature(newOp);
        System.out.println("Checking for duplicate: " + signature);

        // 既存のコードで同じシグネチャを持つメソッドを探す
        for (int i = startLine; i < endLine; i++) {
            String line = lines.get(i).trim();
            if (line.endsWith(";") && line.contains("(")) {
                // 既存メソッドのシグネチャを抽出して比較
                String existingMethod = line.substring(0, line.indexOf(";"))
                        .replaceAll("\\s+", "")
                        .replaceAll("override", "")
                        .replaceAll("virtual", "");
                System.out.println("Comparing with: " + existingMethod);

                if (existingMethod.contains(signature)) {
                    System.out.println("Found duplicate: " + existingMethod);
                    return true;
                }
            }
        }
        return false;
    }

    private String getMethodSignature(Operation op) {
        StringBuilder signature = new StringBuilder();
        signature.append(op.getReturnType().toString())
                .append(op.getName().getNameText())
                .append("(");

        List<Parameter> params = safeGetParameters(op);
        if (!params.isEmpty()) {
            List<String> paramTypes = new ArrayList<>();
            for (Parameter param : params) {
                paramTypes.add(param.getType().toString());
            }
            signature.append(String.join(",", paramTypes));
        }
        signature.append(")");

        return signature.toString().replaceAll("\\s+", "");
    }

    public void removeInheritance(String className, String baseClassName) {
        Optional<CppFile> headerFileOpt = findHeaderFileByClassName(className);
        if (headerFileOpt.isEmpty())
            return;

        try {
            CppFile headerFile = headerFileOpt.get();
            String newCode = translator.removeInheritance(headerFile.getCode(), baseClassName);
            headerFile.updateCode(newCode);
        } catch (Exception e) {
            System.err.println("Failed to remove inheritance: " + e.getMessage());
        }
    }

    public void removeRealization(String className, String interfaceName) {
        Optional<CppFile> headerFileOpt = findHeaderFileByClassName(className);
        if (headerFileOpt.isEmpty())
            return;

        try {
            CppFile headerFile = headerFileOpt.get();
            String newCode = translator.removeInheritance(headerFile.getCode(), interfaceName);
            headerFile.updateCode(newCode);
        } catch (Exception e) {
            System.err.println("Failed to remove realization: " + e.getMessage());
        }
    }

    private int findIncludeInsertPosition(String code) {
        int lastInclude = code.lastIndexOf("#include");
        if (lastInclude == -1)
            return 0;

        int endOfLine = code.indexOf('\n', lastInclude);
        return endOfLine == -1 ? code.length() : endOfLine + 1;
    }
    // public void addAttribute(String className, Attribute attribute) {
    // CppFile headerFile = headerFiles.get(className);
    // if (headerFile == null)
    // return;

    // try {
    // // 型に基づいて必要なヘッダーを追加
    // addRequiredIncludes(headerFile, attribute.getType().toString());

    // // UMLクラスに属性を追加
    // List<Class> umlClasses = headerFile.getUmlClassList();
    // if (!umlClasses.isEmpty()) {
    // Class targetClass = umlClasses.get(0);
    // targetClass.addAttribute(attribute);

    // // ヘッダーファイルを更新
    // String headerCode =
    // translator.translateUmlToCode(Collections.singletonList(targetClass));
    // headerFile.updateCode(headerCode);

    // if (umlController != null) {
    // umlController.updateDiagram(headerFile);
    // }
    // if (codeController != null) {
    // codeController.updateCodeTab(headerFile);
    // }
    // }
    // } catch (Exception e) {
    // System.err.println("Failed to add attribute: " + e.getMessage());
    // }
    // }

    // public void addOperation(String className, Operation operation) {
    // CppFile headerFile = headerFiles.get(className);
    // CppFile implFile = implFiles.get(className);
    // if (headerFile == null || implFile == null)
    // return;

    // try {
    // // UMLクラスに操作を追加
    // List<Class> umlClasses = headerFile.getUmlClassList();
    // if (!umlClasses.isEmpty()) {
    // Class targetClass = umlClasses.get(0);
    // targetClass.addOperation(operation);

    // // ヘッダーファイルを更新
    // String headerCode =
    // translator.translateUmlToCode(Collections.singletonList(targetClass));
    // headerFile.updateCode(headerCode);

    // // 実装ファイルにメソッドの骨組みを追加
    // StringBuilder implCodeBuilder = new StringBuilder();
    // implCodeBuilder.append(toSourceCodeType(operation.getReturnType()))
    // .append(" ")
    // .append(targetClass.getName())
    // .append("::")
    // .append(operation.getName())
    // .append("(");

    // // パラメータの追加
    // List<String> params = new ArrayList<>();
    // operation.getParameters().forEach(param -> {
    // params.add(String.format("%s %s",
    // toSourceCodeType(param.getType()),
    // param.getName()));
    // });
    // implCodeBuilder.append(String.join(", ", params))
    // .append(") {\n // TODO: Implement this method\n}\n\n");

    // String currentImplCode = implFile.getCode();
    // implFile.updateCode(currentImplCode + implCodeBuilder.toString());

    // // コントローラーに通知
    // if (umlController != null) {
    // umlController.updateDiagram(headerFile);
    // }
    // if (codeController != null) {
    // codeController.updateCodeTab(headerFile);
    // codeController.updateCodeTab(implFile);
    // }
    // }
    // } catch (Exception e) {
    // System.err.println("Failed to add operation: " + e.getMessage());
    // }
    // }

    private void updateImplFileForHeaderChange(CppFile headerFile) {
        String baseName = getBaseName(headerFile.getFileName());
        CppFile implFile = implFiles.get(baseName);
        if (implFile != null) {
            System.out.println("DEBUG: Updating implementation file for header change: " +
                    headerFile.getFileName());

            String currentCode = implFile.getCode();
            String expectedInclude = "#include \"" + headerFile.getFileName() + "\"";
            String oldIncludePattern = "#include \".*?.h\"";
            String newCode = currentCode;

            if (!currentCode.contains(expectedInclude)) {
                if (currentCode.matches("(?s).*" + oldIncludePattern + ".*")) {
                    newCode = currentCode.replaceFirst(oldIncludePattern, expectedInclude);
                } else {
                    newCode = expectedInclude + "\n\n" + currentCode;
                }
                implFile.updateCode(newCode);
            }
        }
    }

    public Map<String, CppFile> getHeaderFiles() {
        return Collections.unmodifiableMap(headerFiles);
    }

    public Map<String, CppFile> getImplFiles() {
        return Collections.unmodifiableMap(implFiles);
    }

    public List<CppHeaderClass> getHeaderClasses() {
        List<CppHeaderClass> allClasses = new ArrayList<>();
        for (CppFile headerFile : headerFiles.values()) {
            allClasses.addAll(headerFile.getHeaderClasses());
        }
        System.out.println("CppModel classes: " + allClasses.size());
        for (CppHeaderClass cls : allClasses) {
            CppHeaderClass cppHeaderClass = cls;
            System.out.println("  Class: " + cppHeaderClass.getName());
            System.out.println("  Attributes: " + cls.getAttributeList());
            System.out.println("  Operations: " + cls.getOperationList());
            System.out.println("  Relations: ");
            for (RelationshipInfo relation : cppHeaderClass.getRelationships()) {
                System.out.println("    " + relation.getTargetClass() +
                        " (" + relation.getType() + ")");
                for (RelationshipElement elem : relation.getElements()) {
                    System.out.println("      - " + elem.getName() +
                            " [" + elem.getMultiplicity() + "]");
                }
            }
        }
        return Collections.unmodifiableList(allClasses);
    }

    // public void addGeneralization(String className, String superClassName) {
    // CppFile childFile = headerFiles.get(getBaseName(className));
    // CppFile parentFile = headerFiles.get(getBaseName(superClassName));
    // if (childFile == null || parentFile == null)
    // return;

    // try {
    // List<Class> childClasses = childFile.getUmlClassList();
    // List<Class> parentClasses = parentFile.getUmlClassList();

    // if (!childClasses.isEmpty() && !parentClasses.isEmpty()) {
    // // 継承関係を設定
    // Class childClass = childClasses.get(0);
    // childClass.setSuperClass(parentClasses.get(0));

    // // 親クラスのヘッダーをインクルード
    // String includeStatement = "#include \"" + superClassName + ".h\"";
    // String currentCode = childFile.getCode();
    // if (!currentCode.contains(includeStatement)) {
    // int insertPos = currentCode.indexOf("\n\nclass");
    // if (insertPos != -1) {
    // String newCode = currentCode.substring(0, insertPos) +
    // "\n" + includeStatement +
    // currentCode.substring(insertPos);
    // childFile.updateCode(newCode);
    // }
    // }

    // // 更新されたUMLクラスリストからコードを生成
    // String headerCode =
    // translator.translateUmlToCode(Collections.singletonList(childClass));
    // childFile.updateCode(headerCode);

    // if (umlController != null) {
    // umlController.updateDiagram(childFile);
    // }
    // if (codeController != null) {
    // codeController.updateCodeTab(childFile);
    // }
    // }
    // } catch (Exception e) {
    // System.err.println("Failed to add generalization: " + e.getMessage());
    // }
    // }

    // private void addRequiredIncludes(CppFile file, String type) {
    // Map<String, String> standardIncludes = Map.of(
    // "string", "<string>",
    // "vector", "<vector>",
    // "map", "<map>",
    // "set", "<set>");

    // // テンプレート型の解析（例：vector<string>）
    // if (type.contains("<")) {
    // String baseType = type.substring(0, type.indexOf("<"));
    // if (standardIncludes.containsKey(baseType.toLowerCase())) {
    // addInclude(file, standardIncludes.get(baseType.toLowerCase()));
    // }
    // // 内部の型も再帰的にチェック
    // String innerType = type.substring(type.indexOf("<") + 1,
    // type.lastIndexOf(">"));
    // addRequiredIncludes(file, innerType);
    // } else {
    // if (standardIncludes.containsKey(type.toLowerCase())) {
    // addInclude(file, standardIncludes.get(type.toLowerCase()));
    // }
    // }
    // }

    // private void addInclude(CppFile file, String include) {
    // String currentCode = file.getCode();
    // String includeStatement = "#include " + include;
    // if (!currentCode.contains(includeStatement)) {
    // int insertPos = currentCode.indexOf("\n\nclass");
    // if (insertPos != -1) {
    // String newCode = currentCode.substring(0, insertPos) +
    // "\n" + includeStatement +
    // currentCode.substring(insertPos);
    // file.updateCode(newCode);
    // }
    // }
    // }

    public interface ModelChangeListener {
        void onModelChanged();
    }

    public void addChangeListener(ModelChangeListener listener) {
        changeListeners.add(listener);
    }

    private void notifyModelChanged() {
        for (ModelChangeListener listener : changeListeners) {
            try {
                listener.onModelChanged();
            } catch (Exception e) {
                System.err.println("Error notifying model change: " + e.getMessage());
            }
        }
    }

    // private String toSourceCodeType(Type type) {
    // return translator.translateType(type);
    // }

    public void updateCodeFile(CppFile changedCodeFile, String code) {
        try {
            CppFile file = changedCodeFile;
            System.out.println("DEBUG: Updating code for file: " + file.getFileName());

            updateCode(file, code);

            // ヘッダーファイルでない場合、対応するヘッダーファイルの関係を再解析
            // if (!file.isHeader()) {
            // String baseName = file.getBaseName();
            // CppFile headerFile = headerFiles.get(baseName);
            // if (headerFile != null && !headerFile.getHeaderClasses().isEmpty()) {
            // // 実装ファイルからの関係を解析
            // // analyzeImplementationRelationships(headerFile, file);

            // // 図の更新をトリガー
            // if (umlController != null) {
            // umlController.updateDiagram(headerFile);
            // }
            // }
            // }

        } catch (Exception e) {
            System.err.println("Failed to update code: " + e.getMessage());
        }
    }

    public Optional<CppHeaderClass> findClass(String className) {
        String baseName = getBaseName(className);
        CppFile headerFile = headerFiles.get(baseName);
        if (headerFile != null) {
            List<CppHeaderClass> classes = headerFile.getHeaderClasses();
            if (!classes.isEmpty()) {
                return Optional.of(classes.get(0));
            }
        }
        return Optional.empty();
    }

    public Optional<CppFile> findHeaderFileByClassName(String className) {
        String baseName = getBaseName(className);
        return Optional.ofNullable(headerFiles.get(baseName));
    }

    private String getBaseName(String fileName) {
        return fileName.replaceAll("\\.(h|hpp|cpp)$", "");
    }

    /**
     * 指定されたクラスのメソッドのシーケンス図を生成
     */
    // public String generateSequenceDiagram(String className, String methodName) {
    // Optional<CppFile> headerFileOpt = findHeaderFileByClassName(className);
    // Optional<CppFile> implFileOpt = Optional.ofNullable(findImplFile(className));

    // if (headerFileOpt.isPresent() && implFileOpt.isPresent()) {
    // CppFile headerFile = headerFileOpt.get();
    // CppFile implFile = implFileOpt.get();

    // // デバッグ出力
    // System.out.println("Generating sequence diagram for " + className + "::" +
    // methodName);
    // System.out.println("Header file: " + headerFile.getFileName());
    // System.out.println("Implementation file: " + implFile.getFileName());

    // return translator.generateSequenceDiagram(
    // headerFile.getCode(),
    // implFile.getCode(),
    // methodName);
    // }

    // System.err.println("Could not find necessary files for " + className);
    // return "";
    // }

    /**
     * 実装ファイルを取得する
     *
     * @param className 拡張子を除いたファイル名
     * @return 実装ファイル、存在しない場合はnull
     */
    public CppFile findImplFile(String className) {
        return implFiles.get(className);
    }

    /**
     * ヘッダーファイルを取得する
     *
     * @param baseName 拡張子を除いたファイル名
     * @return ヘッダーファイル、存在しない場合はnull
     */
    public CppFile findHeaderFile(String baseName) {
        return headerFiles.get(baseName);
    }

}
DEBUG: Processing C++ file: A.h
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp;

import io.github.morichan.fescue.feature.visibility.Visibility;
import io.github.morichan.retuss.model.uml.cpp.utils.*;
import java.util.*;
import java.util.stream.Collectors;

public class CppRelationshipManager {
    private final Map<String, Set<RelationshipInfo>> relationshipsByTarget = new HashMap<>();
    private final String sourceClassName; // 関係元のクラス名

    public CppRelationshipManager(String sourceClassName) {
        this.sourceClassName = sourceClassName;
    }

    // 関係の追加
    public void addRelationship(RelationshipInfo relationship) {
        relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())
                .add(relationship);
    }

    public void addRealization(String interfaceName) {
        RelationshipInfo relation = new RelationshipInfo(interfaceName, RelationType.REALIZATION);
        addRelationship(relation);
    }

    // 継承関係の追加
    public void addInheritance(String targetClass) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.INHERITANCE);
        addRelationship(relation);
    }

    // コンポジション関係の追加
    public void addComposition(String targetClass, String memberName, String multiplicity, Visibility visibility) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.COMPOSITION);
        relation.addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility);
        addRelationship(relation);
    }

    // 集約関係の追加
    public void addAggregation(String targetClass, String memberName, String multiplicity, Visibility visibility) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.AGGREGATION);
        relation.addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility);
        addRelationship(relation);
    }

    public void addAssociation(String targetClass, String memberName, String multiplicity, Visibility visibility) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.ASSOCIATION);
        relation.addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility);
        addRelationship(relation);
    }

    // public void addReturnTypeDependency(String targetClass, String memberName,
    // Visibility visibility) {
    // RelationshipInfo relation = new RelationshipInfo(targetClass,
    // RelationType.DEPENDENCY);
    // relation.addElement(
    // memberName,
    // ElementType.OPERATION,
    // "1",
    // Visibility visibility,
    // String type,
    // String returnType,
    // String defaultValue,
    // boolean isPureVirtual,
    // Set<Modifier> modifiers);
    // addRelationship(relation);
    // }

    // 指定したターゲットクラスとの関係を取得
    public Set<RelationshipInfo> getRelationshipsWith(String targetClass) {
        return Collections.unmodifiableSet(
                relationshipsByTarget.getOrDefault(targetClass, new HashSet<>()));
    }

    // 全ての関係を取得
    public Set<RelationshipInfo> getAllRelationships() {
        return relationshipsByTarget.values().stream()
                .flatMap(Set::stream)
                .collect(Collectors.toSet());
    }

    // 特定の種類の関係のみを取得
    public Set<RelationshipInfo> getRelationshipsOfType(RelationType type) {
        return getAllRelationships().stream()
                .filter(r -> r.getType() == type)
                .collect(Collectors.toSet());
    }

    // PlantUML形式の関係文字列を生成
    public String generatePlantUmlRelationships() {
        StringBuilder sb = new StringBuilder();
        Map<String, RelationshipInfo> inheritanceMap = new HashMap<>();
        Map<String, Set<RelationType>> dependencyMap = new HashMap<>();

        // 関係の分類と処理
        for (RelationshipInfo relation : getAllRelationships()) {
            if (relation.getType().isDependency()) {
                // 依存関係の収集
                dependencyMap.computeIfAbsent(relation.getTargetClass(), k -> new HashSet<>())
                        .add(relation.getType());
            } else if (relation.getType() == RelationType.INHERITANCE ||
                    relation.getType() == RelationType.REALIZATION) {
                // 継承/実現関係の処理
                String targetClass = relation.getTargetClass();
                if (relation.getType() == RelationType.REALIZATION ||
                        !inheritanceMap.containsKey(targetClass)) {
                    inheritanceMap.put(targetClass, relation);
                }
            } else {
                // その他の関係（コンポジション、集約、関連）の処理
                appendRegularRelationship(sb, relation);
            }
        }

        // 依存関係の出力
        appendDependencyRelationships(sb, dependencyMap);

        // 継承/実現関係の出力（最後に出力）
        appendInheritanceRelationships(sb, inheritanceMap);

        return sb.toString();
    }

    private void appendRegularRelationship(StringBuilder sb, RelationshipInfo relation) {
        sb.append(sourceClassName)
                .append(" ")
                .append(relation.getType().getPlantUmlText())
                .append(" \"");

        if (!relation.getElements().isEmpty()) {
            RelationshipElement elem = relation.getElements().iterator().next();
            sb.append(elem.getMultiplicity() != null ? elem.getMultiplicity() : "1");
        }

        sb.append("\" ")
                .append(relation.getTargetClass());

        if (!relation.getElements().isEmpty()) {
            RelationshipElement elem = relation.getElements().iterator().next();
            sb.append(" : ").append(elem.getVisibility()).append(elem.getName());
        }

        sb.append("\n");
    }

    private void appendDependencyRelationships(StringBuilder sb,
            Map<String, Set<RelationType>> dependencyMap) {
        for (Map.Entry<String, Set<RelationType>> entry : dependencyMap.entrySet()) {
            sb.append(sourceClassName)
                    .append(" ..> ")
                    .append(entry.getKey())
                    .append(" : <<");

            // ステレオタイプをソートして結合
            String stereotypes = entry.getValue().stream()
                    .map(RelationType::getStereotype)
                    .sorted()
                    .collect(Collectors.joining(", "));

            sb.append(stereotypes)
                    .append(">>\n");
        }
    }

    private void appendInheritanceRelationships(StringBuilder sb,
            Map<String, RelationshipInfo> inheritanceMap) {
        for (RelationshipInfo relation : inheritanceMap.values()) {
            sb.append(sourceClassName)
                    .append(" ")
                    .append(relation.getType().getPlantUmlText())
                    .append(" ")
                    .append(relation.getTargetClass())
                    .append("\n");
        }
    }

    // 特定のターゲットクラスとの関係を削除
    public void removeRelationshipsWith(String targetClass) {
        relationshipsByTarget.remove(targetClass);
    }

    // 特定の種類の関係を全て削除
    public void removeRelationshipsOfType(RelationType type) {
        relationshipsByTarget.values()
                .removeIf(relations -> relations.removeIf(relation -> relation.getType() == type));
    }

    // 関係の検証（例：循環参照のチェックなど）
    public List<String> validateRelationships() {
        List<String> issues = new ArrayList<>();

        // 継承の重複チェック
        long inheritanceCount = getRelationshipsOfType(RelationType.INHERITANCE).size();
        if (inheritanceCount > 1) {
            issues.add("Multiple inheritance detected: " + inheritanceCount + " parent classes");
        }

        // その他の検証ルール
        return issues;
    }
}
DEBUG: Updated UML classes: 1
DEBUG: Class: CppRelationshipManager
DEBUG: Attributes: 2
DEBUG: Operations: 16
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml.cpp;

import io.github.morichan.fescue.feature.visibility.Visibility;
import io.github.morichan.retuss.model.uml.cpp.utils.*;
import java.util.*;
import java.util.stream.Collectors;

public class CppRelationshipManager {

    private final Map<String, Set<RelationshipInfo>> relationshipsByTarget = new HashMap<>();

    // 関係元のクラス名
    private final String sourceClassName;

    public CppRelationshipManager(String sourceClassName) {
        this.sourceClassName = sourceClassName;
    }

    // 関係の追加
    public void addRelationship(RelationshipInfo relationship) {
        relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>()).add(relationship);
    }

    public void addRealization(String interfaceName) {
        RelationshipInfo relation = new RelationshipInfo(interfaceName, RelationType.REALIZATION);
        addRelationship(relation);
    }

    // 継承関係の追加
    public void addInheritance(String targetClass) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.INHERITANCE);
        addRelationship(relation);
    }

    // コンポジション関係の追加
    public void addComposition(String targetClass, String memberName, String multiplicity, Visibility visibility) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.COMPOSITION);
        relation.addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility);
        addRelationship(relation);
    }

    // 集約関係の追加
    public void addAggregation(String targetClass, String memberName, String multiplicity, Visibility visibility) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.AGGREGATION);
        relation.addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility);
        addRelationship(relation);
    }

    public void addAssociation(String targetClass, String memberName, String multiplicity, Visibility visibility) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.ASSOCIATION);
        relation.addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility);
        addRelationship(relation);
    }

    // public void addReturnTypeDependency(String targetClass, String memberName,
    // Visibility visibility) {
    // RelationshipInfo relation = new RelationshipInfo(targetClass,
    // RelationType.DEPENDENCY);
    // relation.addElement(
    // memberName,
    // ElementType.OPERATION,
    // "1",
    // Visibility visibility,
    // String type,
    // String returnType,
    // String defaultValue,
    // boolean isPureVirtual,
    // Set<Modifier> modifiers);
    // addRelationship(relation);
    // }
    // 指定したターゲットクラスとの関係を取得
    public Set<RelationshipInfo> getRelationshipsWith(String targetClass) {
        return Collections.unmodifiableSet(relationshipsByTarget.getOrDefault(targetClass, new HashSet<>()));
    }

    // 全ての関係を取得
    public Set<RelationshipInfo> getAllRelationships() {
        return relationshipsByTarget.values().stream().flatMap(Set::stream).collect(Collectors.toSet());
    }

    // 特定の種類の関係のみを取得
    public Set<RelationshipInfo> getRelationshipsOfType(RelationType type) {
        return getAllRelationships().stream().filter(r -> r.getType() == type).collect(Collectors.toSet());
    }

    // PlantUML形式の関係文字列を生成
    public String generatePlantUmlRelationships() {
        StringBuilder sb = new StringBuilder();
        Map<String, RelationshipInfo> inheritanceMap = new HashMap<>();
        Map<String, Set<RelationType>> dependencyMap = new HashMap<>();
        // 関係の分類と処理
        for (RelationshipInfo relation : getAllRelationships()) {
            if (relation.getType().isDependency()) {
                // 依存関係の収集
                dependencyMap.computeIfAbsent(relation.getTargetClass(), k -> new HashSet<>()).add(relation.getType());
            } else if (relation.getType() == RelationType.INHERITANCE || relation.getType() == RelationType.REALIZATION) {
                // 継承/実現関係の処理
                String targetClass = relation.getTargetClass();
                if (relation.getType() == RelationType.REALIZATION || !inheritanceMap.containsKey(targetClass)) {
                    inheritanceMap.put(targetClass, relation);
                }
            } else {
                // その他の関係（コンポジション、集約、関連）の処理
                appendRegularRelationship(sb, relation);
            }
        }
        // 依存関係の出力
        appendDependencyRelationships(sb, dependencyMap);
        // 継承/実現関係の出力（最後に出力）
        appendInheritanceRelationships(sb, inheritanceMap);
        return sb.toString();
    }

    private void appendRegularRelationship(StringBuilder sb, RelationshipInfo relation) {
        sb.append(sourceClassName).append(" ").append(relation.getType().getPlantUmlText()).append(" \"");
        if (!relation.getElements().isEmpty()) {
            RelationshipElement elem = relation.getElements().iterator().next();
            sb.append(elem.getMultiplicity() != null ? elem.getMultiplicity() : "1");
        }
        sb.append("\" ").append(relation.getTargetClass());
        if (!relation.getElements().isEmpty()) {
            RelationshipElement elem = relation.getElements().iterator().next();
            sb.append(" : ").append(elem.getVisibility()).append(elem.getName());
        }
        sb.append("\n");
    }

    private void appendDependencyRelationships(StringBuilder sb, Map<String, Set<RelationType>> dependencyMap) {
        for (Map.Entry<String, Set<RelationType>> entry : dependencyMap.entrySet()) {
            sb.append(sourceClassName).append(" ..> ").append(entry.getKey()).append(" : <<");
            // ステレオタイプをソートして結合
            String stereotypes = entry.getValue().stream().map(RelationType::getStereotype).sorted().collect(Collectors.joining(", "));
            sb.append(stereotypes).append(">>\n");
        }
    }

    private void appendInheritanceRelationships(StringBuilder sb, Map<String, RelationshipInfo> inheritanceMap) {
        for (RelationshipInfo relation : inheritanceMap.values()) {
            sb.append(sourceClassName).append(" ").append(relation.getType().getPlantUmlText()).append(" ").append(relation.getTargetClass()).append("\n");
        }
    }

    // 特定のターゲットクラスとの関係を削除
    public void removeRelationshipsWith(String targetClass) {
        relationshipsByTarget.remove(targetClass);
    }

    // 特定の種類の関係を全て削除
    public void removeRelationshipsOfType(RelationType type) {
        relationshipsByTarget.values().removeIf(relations -> relations.removeIf(relation -> relation.getType() == type));
    }

    // 関係の検証（例：循環参照のチェックなど）
    public List<String> validateRelationships() {
        List<String> issues = new ArrayList<>();
        // 継承の重複チェック
        long inheritanceCount = getRelationshipsOfType(RelationType.INHERITANCE).size();
        if (inheritanceCount > 1) {
            issues.add("Multiple inheritance detected: " + inheritanceCount + " parent classes");
        }
        // その他の検証ルール
        return issues;
    }
}

DEBUG: Updating diagram for file: CppRelationshipManager.java
DEBUG: Updating Java diagrams
DEBUG: Java diagrams update completed
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp;

import java.util.*;
import io.github.morichan.fescue.feature.*;
import io.github.morichan.retuss.model.uml.Interaction;
import io.github.morichan.retuss.model.uml.cpp.utils.*;

public class CppHeaderClass {
    // メンバー変数
    private String name = "";
    private Boolean isAbstruct = false;
    private Boolean isInterface = false;
    private Boolean isActive; // 宣言されてたかどうか
    // private CppHeaderClass superClass;
    private List<CppHeaderClass> superClasses = new ArrayList<>();
    private List<Attribute> attributeList = new ArrayList<>();
    private List<Operation> operationList = new ArrayList<>();
    private List<Interaction> interactionList = new ArrayList<>();
    private final Map<String, Set<Modifier>> memberModifiers = new HashMap<>();
    private final CppRelationshipManager relationshipManager;

    // メンバー修飾子の管理
    public void addMemberModifier(String memberName, Modifier modifier) {
        memberModifiers.computeIfAbsent(memberName, k -> EnumSet.noneOf(Modifier.class))
                .add(modifier);
    }

    public Set<Modifier> getModifiers(String memberName) {
        return Collections.unmodifiableSet(
                memberModifiers.getOrDefault(memberName, EnumSet.noneOf(Modifier.class)));
    }

    // 関係の管理
    public void addRelationship(RelationshipInfo relationship) {
        relationshipManager.addRelationship(relationship);
    }

    public Set<RelationshipInfo> getRelationships() {
        return relationshipManager.getAllRelationships();
    }

    public CppRelationshipManager getRelationshipManager() {
        return relationshipManager;
    }

    public CppHeaderClass(String name) {
        this.name = name;
        this.isActive = true;
        this.relationshipManager = new CppRelationshipManager(name);
    }

    public CppHeaderClass(String name, Boolean isActive) {
        this.name = name;
        this.isActive = isActive;
        this.relationshipManager = new CppRelationshipManager(name);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Boolean getAbstruct() {
        return isAbstruct;
    }

    public void setAbstruct(Boolean abstruct) {
        isAbstruct = abstruct;
    }

    public Boolean getInterface() {
        return isInterface;
    }

    public void setInterface(Boolean abstruct) {
        isInterface = abstruct;
    }

    public Boolean getActive() {
        return isActive;
    }

    public void setActive(Boolean active) {
        isActive = active;
    }

    public List<CppHeaderClass> getSuperClasses() {
        return Collections.unmodifiableList(superClasses);
    }

    public void setSuperClass(CppHeaderClass superClass) {
        if (!superClasses.contains(superClass)) {
            superClasses.add(superClass);
        }
        if (superClass != null) {
            relationshipManager.addInheritance(superClass.getName());
        }
    }

    public List<Attribute> getAttributeList() {
        return Collections.unmodifiableList(attributeList);
    }

    public List<Operation> getOperationList() {
        return Collections.unmodifiableList(operationList);
    }

    public List<Interaction> getInteractionList() {
        return Collections.unmodifiableList(interactionList);
    }

    public void addAttribute(Attribute attribute) {
        attributeList.add(attribute);
    }

    public void addOperation(Operation operation) {
        operationList.add(operation);
        addInteraction(new Interaction(operation, operation.toString()));
    }

    public void addOperation(Operation operation, Interaction interaction) {
        operationList.add(operation);
        addInteraction(interaction);
    }

    public void addInteraction(Interaction interaction) {
        interactionList.add(interaction);
    }

    public void removeAttribute(Attribute attribute) {
        attributeList.remove(attribute);
    }

    public void removeOperation(Operation operation) {
        operationList.remove(operation);
        for (Interaction interaction : interactionList) {
            if (operation.equals(interaction.getOperation())) {
                removeInteraction(interaction);
                return;
            }
        }
    }

    public void removeInteraction(Interaction interaction) {
        interactionList.remove(interaction);
    }

    public Optional<Operation> findOperation(String operationId) {
        for (Operation operation : operationList) {
            if (operation.toString().equals(operationId)) {
                return Optional.of(operation);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(Operation operation) {
        for (Interaction interaction : interactionList) {
            if (interaction.getOperation().equals(operation)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(String operationName) {
        // 同じ名前のInteractionが複数あるとダメ
        for (Interaction interaction : interactionList) {
            if (interaction.getOperation().getName().getNameText().equals(operationName)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    public String toString() {
        return this.name;
    }
}
DEBUG: Updated UML classes: 1
DEBUG: Class: CppHeaderClass
DEBUG: Attributes: 10
DEBUG: Operations: 29
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml.cpp;

import java.util.*;
import io.github.morichan.fescue.feature.*;
import io.github.morichan.retuss.model.uml.Interaction;
import io.github.morichan.retuss.model.uml.cpp.utils.*;

public class CppHeaderClass {

    // メンバー変数
    private String name = "";

    private Boolean isAbstruct = false;

    private Boolean isInterface = false;

    // 宣言されてたかどうか
    private Boolean isActive;

    // private CppHeaderClass superClass;
    private List<CppHeaderClass> superClasses = new ArrayList<>();

    private List<Attribute> attributeList = new ArrayList<>();

    private List<Operation> operationList = new ArrayList<>();

    private List<Interaction> interactionList = new ArrayList<>();

    private final Map<String, Set<Modifier>> memberModifiers = new HashMap<>();

    private final CppRelationshipManager relationshipManager;

    // メンバー修飾子の管理
    public void addMemberModifier(String memberName, Modifier modifier) {
        memberModifiers.computeIfAbsent(memberName, k -> EnumSet.noneOf(Modifier.class)).add(modifier);
    }

    public Set<Modifier> getModifiers(String memberName) {
        return Collections.unmodifiableSet(memberModifiers.getOrDefault(memberName, EnumSet.noneOf(Modifier.class)));
    }

    // 関係の管理
    public void addRelationship(RelationshipInfo relationship) {
        relationshipManager.addRelationship(relationship);
    }

    public Set<RelationshipInfo> getRelationships() {
        return relationshipManager.getAllRelationships();
    }

    public CppRelationshipManager getRelationshipManager() {
        return relationshipManager;
    }

    public CppHeaderClass(String name) {
        this.name = name;
        this.isActive = true;
        this.relationshipManager = new CppRelationshipManager(name);
    }

    public CppHeaderClass(String name, Boolean isActive) {
        this.name = name;
        this.isActive = isActive;
        this.relationshipManager = new CppRelationshipManager(name);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Boolean getAbstruct() {
        return isAbstruct;
    }

    public void setAbstruct(Boolean abstruct) {
        isAbstruct = abstruct;
    }

    public Boolean getInterface() {
        return isInterface;
    }

    public void setInterface(Boolean abstruct) {
        isInterface = abstruct;
    }

    public Boolean getActive() {
        return isActive;
    }

    public void setActive(Boolean active) {
        isActive = active;
    }

    public List<CppHeaderClass> getSuperClasses() {
        return Collections.unmodifiableList(superClasses);
    }

    public void setSuperClass(CppHeaderClass superClass) {
        if (!superClasses.contains(superClass)) {
            superClasses.add(superClass);
        }
        if (superClass != null) {
            relationshipManager.addInheritance(superClass.getName());
        }
    }

    public List<Attribute> getAttributeList() {
        return Collections.unmodifiableList(attributeList);
    }

    public List<Operation> getOperationList() {
        return Collections.unmodifiableList(operationList);
    }

    public List<Interaction> getInteractionList() {
        return Collections.unmodifiableList(interactionList);
    }

    public void addAttribute(Attribute attribute) {
        attributeList.add(attribute);
    }

    public void addOperation(Operation operation) {
        operationList.add(operation);
        addInteraction(new Interaction(operation, operation.toString()));
    }

    public void addOperation(Operation operation, Interaction interaction) {
        operationList.add(operation);
        addInteraction(interaction);
    }

    public void addInteraction(Interaction interaction) {
        interactionList.add(interaction);
    }

    public void removeAttribute(Attribute attribute) {
        attributeList.remove(attribute);
    }

    public void removeOperation(Operation operation) {
        operationList.remove(operation);
        for (Interaction interaction : interactionList) {
            if (operation.equals(interaction.getOperation())) {
                removeInteraction(interaction);
                return;
            }
        }
    }

    public void removeInteraction(Interaction interaction) {
        interactionList.remove(interaction);
    }

    public Optional<Operation> findOperation(String operationId) {
        for (Operation operation : operationList) {
            if (operation.toString().equals(operationId)) {
                return Optional.of(operation);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(Operation operation) {
        for (Interaction interaction : interactionList) {
            if (interaction.getOperation().equals(operation)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(String operationName) {
        // 同じ名前のInteractionが複数あるとダメ
        for (Interaction interaction : interactionList) {
            if (interaction.getOperation().getName().getNameText().equals(operationName)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    public String toString() {
        return this.name;
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp;

import io.github.morichan.fescue.feature.visibility.Visibility;
import io.github.morichan.retuss.model.uml.cpp.utils.*;
import java.util.*;
import java.util.stream.Collectors;

public class CppRelationshipManager {

    private final Map<String, Set<RelationshipInfo>> relationshipsByTarget = new HashMap<>();

    // 関係元のクラス名
    private final String sourceClassName;

    public CppRelationshipManager(String sourceClassName) {
        this.sourceClassName = sourceClassName;
    }

    // 関係の追加
    public void addRelationship(RelationshipInfo relationship) {
        relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>()).add(relationship);
    }

    public void addRealization(String interfaceName) {
        RelationshipInfo relation = new RelationshipInfo(interfaceName, RelationType.REALIZATION);
        addRelationship(relation);
    }

    // 継承関係の追加
    public void addInheritance(String targetClass) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.INHERITANCE);
        addRelationship(relation);
    }

    // コンポジション関係の追加
    public void addComposition(String targetClass, String memberName, String multiplicity, Visibility visibility) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.COMPOSITION);
        relation.addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility);
        addRelationship(relation);
    }

    // 集約関係の追加
    public void addAggregation(String targetClass, String memberName, String multiplicity, Visibility visibility) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.AGGREGATION);
        relation.addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility);
        addRelationship(relation);
    }

    public void addAssociation(String targetClass, String memberName, String multiplicity, Visibility visibility) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.ASSOCIATION);
        relation.addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility);
        addRelationship(relation);
    }

    // public void addReturnTypeDependency(String targetClass, String memberName,
    // Visibility visibility) {
    // RelationshipInfo relation = new RelationshipInfo(targetClass,
    // RelationType.DEPENDENCY);
    // relation.addElement(
    // memberName,
    // ElementType.OPERATION,
    // "1",
    // Visibility visibility,
    // String type,
    // String returnType,
    // String defaultValue,
    // boolean isPureVirtual,
    // Set<Modifier> modifiers);
    // addRelationship(relation);
    // }
    // 指定したターゲットクラスとの関係を取得
    public Set<RelationshipInfo> getRelationshipsWith(String targetClass) {
        return Collections.unmodifiableSet(relationshipsByTarget.getOrDefault(targetClass, new HashSet<>()));
    }

    // 全ての関係を取得
    public Set<RelationshipInfo> getAllRelationships() {
        return relationshipsByTarget.values().stream().flatMap(Set::stream).collect(Collectors.toSet());
    }

    // 特定の種類の関係のみを取得
    public Set<RelationshipInfo> getRelationshipsOfType(RelationType type) {
        return getAllRelationships().stream().filter(r -> r.getType() == type).collect(Collectors.toSet());
    }

    // PlantUML形式の関係文字列を生成
    public String generatePlantUmlRelationships() {
        StringBuilder sb = new StringBuilder();
        Map<String, RelationshipInfo> inheritanceMap = new HashMap<>();
        Map<String, Set<RelationType>> dependencyMap = new HashMap<>();
        // 関係の分類と処理
        for (RelationshipInfo relation : getAllRelationships()) {
            if (relation.getType().isDependency()) {
                // 依存関係の収集
                dependencyMap.computeIfAbsent(relation.getTargetClass(), k -> new HashSet<>()).add(relation.getType());
            } else if (relation.getType() == RelationType.INHERITANCE || relation.getType() == RelationType.REALIZATION) {
                // 継承/実現関係の処理
                String targetClass = relation.getTargetClass();
                if (relation.getType() == RelationType.REALIZATION || !inheritanceMap.containsKey(targetClass)) {
                    inheritanceMap.put(targetClass, relation);
                }
            } else {
                // その他の関係（コンポジション、集約、関連）の処理
                appendRegularRelationship(sb, relation);
            }
        }
        // 依存関係の出力
        appendDependencyRelationships(sb, dependencyMap);
        // 継承/実現関係の出力（最後に出力）
        appendInheritanceRelationships(sb, inheritanceMap);
        return sb.toString();
    }

    private void appendRegularRelationship(StringBuilder sb, RelationshipInfo relation) {
        sb.append(sourceClassName).append(" ").append(relation.getType().getPlantUmlText()).append(" \"");
        if (!relation.getElements().isEmpty()) {
            RelationshipElement elem = relation.getElements().iterator().next();
            sb.append(elem.getMultiplicity() != null ? elem.getMultiplicity() : "1");
        }
        sb.append("\" ").append(relation.getTargetClass());
        if (!relation.getElements().isEmpty()) {
            RelationshipElement elem = relation.getElements().iterator().next();
            sb.append(" : ").append(elem.getVisibility()).append(elem.getName());
        }
        sb.append("\n");
    }

    private void appendDependencyRelationships(StringBuilder sb, Map<String, Set<RelationType>> dependencyMap) {
        for (Map.Entry<String, Set<RelationType>> entry : dependencyMap.entrySet()) {
            sb.append(sourceClassName).append(" ..> ").append(entry.getKey()).append(" : <<");
            // ステレオタイプをソートして結合
            String stereotypes = entry.getValue().stream().map(RelationType::getStereotype).sorted().collect(Collectors.joining(", "));
            sb.append(stereotypes).append(">>\n");
        }
    }

    private void appendInheritanceRelationships(StringBuilder sb, Map<String, RelationshipInfo> inheritanceMap) {
        for (RelationshipInfo relation : inheritanceMap.values()) {
            sb.append(sourceClassName).append(" ").append(relation.getType().getPlantUmlText()).append(" ").append(relation.getTargetClass()).append("\n");
        }
    }

    // 特定のターゲットクラスとの関係を削除
    public void removeRelationshipsWith(String targetClass) {
        relationshipsByTarget.remove(targetClass);
    }

    // 特定の種類の関係を全て削除
    public void removeRelationshipsOfType(RelationType type) {
        relationshipsByTarget.values().removeIf(relations -> relations.removeIf(relation -> relation.getType() == type));
    }

    // 関係の検証（例：循環参照のチェックなど）
    public List<String> validateRelationships() {
        List<String> issues = new ArrayList<>();
        // 継承の重複チェック
        long inheritanceCount = getRelationshipsOfType(RelationType.INHERITANCE).size();
        if (inheritanceCount > 1) {
            issues.add("Multiple inheritance detected: " + inheritanceCount + " parent classes");
        }
        // その他の検証ルール
        return issues;
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: CppRelationshipManager
DEBUG: Attributes: 2
DEBUG: Operations: 16
DEBUG: Updating diagram for file: CppRelationshipManager.java
DEBUG: Updating diagram for file: CppHeaderClass.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp;

import io.github.morichan.fescue.feature.visibility.Visibility;
import io.github.morichan.retuss.model.uml.cpp.utils.*;
import java.util.*;

public class CppImplClass {
    private final CppHeaderClass headerClass;
    private final Map<String, List<LocalVariable>> methodLocals;
    private final Set<String> includes;
    private final Set<String> usingDirectives;
    private final CppRelationshipManager relationshipManager;

    public CppImplClass(CppHeaderClass headerClass) {
        this.headerClass = headerClass;
        this.methodLocals = new HashMap<>();
        this.includes = new LinkedHashSet<>();
        this.usingDirectives = new LinkedHashSet<>();
        this.relationshipManager = new CppRelationshipManager(headerClass.getName());

        // ヘッダーファイルのインクルードを自動追加
        addInclude("\"" + headerClass.getName() + ".h\"");
    }

    // ローカル変数の定義
    public static class LocalVariable {
        private final String name;
        private final String type;
        private final String initialValue;
        private final Set<Modifier> modifiers;

        public LocalVariable(String name, String type, String initialValue, Set<Modifier> modifiers) {
            this.name = name;
            this.type = type;
            this.initialValue = initialValue;
            this.modifiers = modifiers != null ? EnumSet.copyOf(modifiers) : EnumSet.noneOf(Modifier.class);
        }

        public String getName() {
            return name;
        }

        public String getType() {
            return type;
        }

        public String getInitialValue() {
            return initialValue;
        }

        public Set<Modifier> getModifiers() {
            return Collections.unmodifiableSet(modifiers);
        }
    }

    // ローカル変数の管理
    public void addLocalVariable(String methodName, LocalVariable variable) {
        methodLocals.computeIfAbsent(methodName, k -> new ArrayList<>())
                .add(variable);

        if (!isBuiltInType(variable.getType())) {
            RelationshipInfo relation = new RelationshipInfo(
                    extractClassName(variable.getType()),
                    RelationType.DEPENDENCY_USE);

            relation.addElement(
                    variable.getName(), // name
                    ElementType.LOCAL_VARIABLE, // elemType
                    "1", // multiplicity
                    Visibility.Private // visibility
            );

            relationshipManager.addRelationship(relation);
            addInclude("\"" + extractClassName(variable.getType()) + ".h\"");
        }
    }

    public List<LocalVariable> getLocalVariables(String methodName) {
        return Collections.unmodifiableList(
                methodLocals.getOrDefault(methodName, new ArrayList<>()));
    }

    public void clearLocalVariables() {
        methodLocals.clear();
    }

    // インクルードの管理
    public void addInclude(String include) {
        includes.add(include);
    }

    public Set<String> getIncludes() {
        return Collections.unmodifiableSet(includes);
    }

    // using ディレクティブの管理
    public void addUsingDirective(String using) {
        usingDirectives.add(using);
    }

    public Set<String> getUsingDirectives() {
        return Collections.unmodifiableSet(usingDirectives);
    }

    // 関係管理
    public void addMethodCall(String targetClass, String methodName,
            String callingMethod) {
        RelationshipInfo relation = new RelationshipInfo(
                targetClass,
                RelationType.DEPENDENCY_USE); // METHOD_CALL

        relation.addElement(
                methodName, // name
                ElementType.METHOD_CALL, // elemType
                "1", // multiplicity
                Visibility.Public // visibility
        );

        relationshipManager.addRelationship(relation);
        addInclude("\"" + targetClass + ".h\"");
    }

    public void addTemporaryObject(String targetClass, String context) {
        RelationshipInfo relation = new RelationshipInfo(
                targetClass,
                RelationType.DEPENDENCY_USE);

        relation.addElement(
                "temp_" + context, // name
                ElementType.TEMPORARY, // elemType
                "1", // multiplicity
                Visibility.Private // visibility
        );

        relationshipManager.addRelationship(relation);
    }

    public void addParameterType(String targetClass, String paramName, String methodName) {
        RelationshipInfo relation = new RelationshipInfo(
                targetClass,
                RelationType.DEPENDENCY_USE);

        relation.addElement(
                paramName, // name
                ElementType.PARAMETER, // elemType
                "1", // multiplicity
                Visibility.Private // visibility
        );

        relationshipManager.addRelationship(relation);

        // 必要なインクルードを自動追加
        addInclude("\"" + targetClass + ".h\"");
    }

    public CppRelationshipManager getRelationshipManager() {
        return relationshipManager;
    }

    public Set<RelationshipInfo> getRelationships() {
        return relationshipManager.getAllRelationships();
    }

    private boolean isBuiltInType(String type) {
        Set<String> builtInTypes = Set.of(
                "void", "bool", "char", "int", "long", "float", "double",
                "size_t", "string", "vector", "map", "set");
        return builtInTypes.contains(extractBaseType(type).toLowerCase());
    }

    private String extractClassName(String type) {
        // テンプレート型からクラス名を抽出
        int templateStart = type.indexOf('<');
        return templateStart == -1 ? type : type.substring(0, templateStart).trim();
    }

    private String extractBaseType(String type) {
        // ポインタ、参照、const修飾子を除去
        return type.replaceAll("\\s*[*&]\\s*$", "") // ポインタ/参照を除去
                .replaceAll("^\\s*const\\s+", "") // constを除去
                .replaceAll("<.*>", "") // テンプレートパラメータを除去
                .trim();
    }

    public CppHeaderClass getHeaderClass() {
        return headerClass;
    }
}
DEBUG: Updated UML classes: 2
DEBUG: Class: CppImplClass
DEBUG: Attributes: 9
DEBUG: Operations: 20
DEBUG: Class: LocalVariable
DEBUG: Attributes: 4
DEBUG: Operations: 4
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml.cpp;

import io.github.morichan.fescue.feature.visibility.Visibility;
import io.github.morichan.retuss.model.uml.cpp.utils.*;
import java.util.*;

public class CppImplClass {

    private final CppHeaderClass headerClass;

    private final Map<String, List<LocalVariable>> methodLocals;

    private final Set<String> includes;

    private final Set<String> usingDirectives;

    private final CppRelationshipManager relationshipManager;

    public CppImplClass(CppHeaderClass headerClass) {
        this.headerClass = headerClass;
        this.methodLocals = new HashMap<>();
        this.includes = new LinkedHashSet<>();
        this.usingDirectives = new LinkedHashSet<>();
        this.relationshipManager = new CppRelationshipManager(headerClass.getName());
        // ヘッダーファイルのインクルードを自動追加
        addInclude("\"" + headerClass.getName() + ".h\"");
    }

    // ローカル変数の定義
    public static class LocalVariable {

        private final String name;

        private final String type;

        private final String initialValue;

        private final Set<Modifier> modifiers;

        public LocalVariable(String name, String type, String initialValue, Set<Modifier> modifiers) {
            this.name = name;
            this.type = type;
            this.initialValue = initialValue;
            this.modifiers = modifiers != null ? EnumSet.copyOf(modifiers) : EnumSet.noneOf(Modifier.class);
        }

        public String getName() {
            return name;
        }

        public String getType() {
            return type;
        }

        public String getInitialValue() {
            return initialValue;
        }

        public Set<Modifier> getModifiers() {
            return Collections.unmodifiableSet(modifiers);
        }
    }

    // ローカル変数の管理
    public void addLocalVariable(String methodName, LocalVariable variable) {
        methodLocals.computeIfAbsent(methodName, k -> new ArrayList<>()).add(variable);
        if (!isBuiltInType(variable.getType())) {
            RelationshipInfo relation = new RelationshipInfo(extractClassName(variable.getType()), RelationType.DEPENDENCY_USE);
            relation.addElement(// name
            variable.getName(), // elemType
            ElementType.LOCAL_VARIABLE, // multiplicity
            "1", // visibility
            Visibility.Private);
            relationshipManager.addRelationship(relation);
            addInclude("\"" + extractClassName(variable.getType()) + ".h\"");
        }
    }

    public List<LocalVariable> getLocalVariables(String methodName) {
        return Collections.unmodifiableList(methodLocals.getOrDefault(methodName, new ArrayList<>()));
    }

    public void clearLocalVariables() {
        methodLocals.clear();
    }

    // インクルードの管理
    public void addInclude(String include) {
        includes.add(include);
    }

    public Set<String> getIncludes() {
        return Collections.unmodifiableSet(includes);
    }

    // using ディレクティブの管理
    public void addUsingDirective(String using) {
        usingDirectives.add(using);
    }

    public Set<String> getUsingDirectives() {
        return Collections.unmodifiableSet(usingDirectives);
    }

    // 関係管理
    public void addMethodCall(String targetClass, String methodName, String callingMethod) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, // METHOD_CALL
        RelationType.DEPENDENCY_USE);
        relation.addElement(// name
        methodName, // elemType
        ElementType.METHOD_CALL, // multiplicity
        "1", // visibility
        Visibility.Public);
        relationshipManager.addRelationship(relation);
        addInclude("\"" + targetClass + ".h\"");
    }

    public void addTemporaryObject(String targetClass, String context) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.DEPENDENCY_USE);
        relation.addElement(// name
        "temp_" + context, // elemType
        ElementType.TEMPORARY, // multiplicity
        "1", // visibility
        Visibility.Private);
        relationshipManager.addRelationship(relation);
    }

    public void addParameterType(String targetClass, String paramName, String methodName) {
        RelationshipInfo relation = new RelationshipInfo(targetClass, RelationType.DEPENDENCY_USE);
        relation.addElement(// name
        paramName, // elemType
        ElementType.PARAMETER, // multiplicity
        "1", // visibility
        Visibility.Private);
        relationshipManager.addRelationship(relation);
        // 必要なインクルードを自動追加
        addInclude("\"" + targetClass + ".h\"");
    }

    public CppRelationshipManager getRelationshipManager() {
        return relationshipManager;
    }

    public Set<RelationshipInfo> getRelationships() {
        return relationshipManager.getAllRelationships();
    }

    private boolean isBuiltInType(String type) {
        Set<String> builtInTypes = Set.of("void", "bool", "char", "int", "long", "float", "double", "size_t", "string", "vector", "map", "set");
        return builtInTypes.contains(extractBaseType(type).toLowerCase());
    }

    private String extractClassName(String type) {
        // テンプレート型からクラス名を抽出
        int templateStart = type.indexOf('<');
        return templateStart == -1 ? type : type.substring(0, templateStart).trim();
    }

    private String extractBaseType(String type) {
        // ポインタ、参照、const修飾子を除去
        return // ポインタ/参照を除去
        type.replaceAll("\\s*[*&]\\s*$", "").replaceAll("^\\s*const\\s+", // constを除去
        "").replaceAll("<.*>", // テンプレートパラメータを除去
        "").trim();
    }

    public CppHeaderClass getHeaderClass() {
        return headerClass;
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp;

import java.util.*;
import io.github.morichan.fescue.feature.*;
import io.github.morichan.retuss.model.uml.Interaction;
import io.github.morichan.retuss.model.uml.cpp.utils.*;

public class CppHeaderClass {

    // メンバー変数
    private String name = "";

    private Boolean isAbstruct = false;

    private Boolean isInterface = false;

    // 宣言されてたかどうか
    private Boolean isActive;

    // private CppHeaderClass superClass;
    private List<CppHeaderClass> superClasses = new ArrayList<>();

    private List<Attribute> attributeList = new ArrayList<>();

    private List<Operation> operationList = new ArrayList<>();

    private List<Interaction> interactionList = new ArrayList<>();

    private final Map<String, Set<Modifier>> memberModifiers = new HashMap<>();

    private final CppRelationshipManager relationshipManager;

    // メンバー修飾子の管理
    public void addMemberModifier(String memberName, Modifier modifier) {
        memberModifiers.computeIfAbsent(memberName, k -> EnumSet.noneOf(Modifier.class)).add(modifier);
    }

    public Set<Modifier> getModifiers(String memberName) {
        return Collections.unmodifiableSet(memberModifiers.getOrDefault(memberName, EnumSet.noneOf(Modifier.class)));
    }

    // 関係の管理
    public void addRelationship(RelationshipInfo relationship) {
        relationshipManager.addRelationship(relationship);
    }

    public Set<RelationshipInfo> getRelationships() {
        return relationshipManager.getAllRelationships();
    }

    public CppRelationshipManager getRelationshipManager() {
        return relationshipManager;
    }

    public CppHeaderClass(String name) {
        this.name = name;
        this.isActive = true;
        this.relationshipManager = new CppRelationshipManager(name);
    }

    public CppHeaderClass(String name, Boolean isActive) {
        this.name = name;
        this.isActive = isActive;
        this.relationshipManager = new CppRelationshipManager(name);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Boolean getAbstruct() {
        return isAbstruct;
    }

    public void setAbstruct(Boolean abstruct) {
        isAbstruct = abstruct;
    }

    public Boolean getInterface() {
        return isInterface;
    }

    public void setInterface(Boolean abstruct) {
        isInterface = abstruct;
    }

    public Boolean getActive() {
        return isActive;
    }

    public void setActive(Boolean active) {
        isActive = active;
    }

    public List<CppHeaderClass> getSuperClasses() {
        return Collections.unmodifiableList(superClasses);
    }

    public void setSuperClass(CppHeaderClass superClass) {
        if (!superClasses.contains(superClass)) {
            superClasses.add(superClass);
        }
        if (superClass != null) {
            relationshipManager.addInheritance(superClass.getName());
        }
    }

    public List<Attribute> getAttributeList() {
        return Collections.unmodifiableList(attributeList);
    }

    public List<Operation> getOperationList() {
        return Collections.unmodifiableList(operationList);
    }

    public List<Interaction> getInteractionList() {
        return Collections.unmodifiableList(interactionList);
    }

    public void addAttribute(Attribute attribute) {
        attributeList.add(attribute);
    }

    public void addOperation(Operation operation) {
        operationList.add(operation);
        addInteraction(new Interaction(operation, operation.toString()));
    }

    public void addOperation(Operation operation, Interaction interaction) {
        operationList.add(operation);
        addInteraction(interaction);
    }

    public void addInteraction(Interaction interaction) {
        interactionList.add(interaction);
    }

    public void removeAttribute(Attribute attribute) {
        attributeList.remove(attribute);
    }

    public void removeOperation(Operation operation) {
        operationList.remove(operation);
        for (Interaction interaction : interactionList) {
            if (operation.equals(interaction.getOperation())) {
                removeInteraction(interaction);
                return;
            }
        }
    }

    public void removeInteraction(Interaction interaction) {
        interactionList.remove(interaction);
    }

    public Optional<Operation> findOperation(String operationId) {
        for (Operation operation : operationList) {
            if (operation.toString().equals(operationId)) {
                return Optional.of(operation);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(Operation operation) {
        for (Interaction interaction : interactionList) {
            if (interaction.getOperation().equals(operation)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(String operationName) {
        // 同じ名前のInteractionが複数あるとダメ
        for (Interaction interaction : interactionList) {
            if (interaction.getOperation().getName().getNameText().equals(operationName)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    public String toString() {
        return this.name;
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: CppHeaderClass
DEBUG: Attributes: 10
DEBUG: Operations: 29
DEBUG: Updating diagram for file: CppHeaderClass.java
DEBUG: Updating diagram for file: CppImplClass.java
DEBUG: Processing C++ file: A.h
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.parameter.Parameter;
import io.github.morichan.fescue.feature.type.Type;

import java.util.ArrayList;
import java.util.Objects;


public class Message {
    private String name = "";
    private ArrayList<Parameter> parameterList = new ArrayList<>();
    private Type replyType;
    private OccurenceSpecification messageEnd;
    private MessageSort messageSort = MessageSort.synchCall;


    public Message(String name, OccurenceSpecification messageEnd) {
        this.name = name;
        this.messageEnd = messageEnd;
    }

    public String getName() {
        return name;
    }

    public ArrayList<Parameter> getParameterList() {
        return parameterList;
    }

    public void setParameterList(ArrayList<Parameter> parameterList) {
        this.parameterList = parameterList;
    }

    public Type getReplyType() {
        return replyType;
    }

    public OccurenceSpecification getMessageEnd() {
        return messageEnd;
    }

    public MessageSort getMessageSort() { return messageSort; }

    public void setMessageSort(MessageSort messageSort) { this.messageSort = messageSort; }


    public String getSignature() {
        StringBuilder sb = new StringBuilder();

        if (this.messageSort == MessageSort.synchCall) {
            sb.append(name);
            // 引数
            sb.append("(");
            sb.append(parameterListToSignateru());
            sb.append(")");
            // 戻り値の型
            if(Objects.nonNull(replyType)) {
                sb.append(String.format(" : %s\n", replyType.getName()));
            }

        } else if (this.messageSort == MessageSort.createMessage) {
            if (parameterList.size() == 0) {
                sb.append("<<create>>");
            } else {
                sb.append("create");
                // 引数
                sb.append("(");
                sb.append(parameterListToSignateru());
                sb.append(")");
                // 戻り値の型
                if(Objects.nonNull(replyType)) {
                    sb.append(String.format(" : %s\n", replyType.getName()));
                }
            }
        }

        return sb.toString();
    }

    private String parameterListToSignateru() {
        StringBuilder sb = new StringBuilder();

        if(parameterList.size() > 0) {
            for(Parameter parameter : parameterList) {
                sb.append(parameter.getName());
                try {
                    sb.append(String.format(" : %s", parameter.getType()));
                } catch (Exception e) {

                }
                if(parameterList.indexOf(parameter) < parameterList.size() - 1) {
                    sb.append(", ");
                }
            }
        }

        return sb.toString();
    }

    @Override
    public String toString() {
        return getSignature();
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: Message
DEBUG: Attributes: 5
DEBUG: Operations: 10
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.parameter.Parameter;
import io.github.morichan.fescue.feature.type.Type;
import java.util.ArrayList;
import java.util.Objects;

public class Message {

    private String name = "";

    private ArrayList<Parameter> parameterList = new ArrayList<>();

    private Type replyType;

    private OccurenceSpecification messageEnd;

    private MessageSort messageSort = MessageSort.synchCall;

    public Message(String name, OccurenceSpecification messageEnd) {
        this.name = name;
        this.messageEnd = messageEnd;
    }

    public String getName() {
        return name;
    }

    public ArrayList<Parameter> getParameterList() {
        return parameterList;
    }

    public void setParameterList(ArrayList<Parameter> parameterList) {
        this.parameterList = parameterList;
    }

    public Type getReplyType() {
        return replyType;
    }

    public OccurenceSpecification getMessageEnd() {
        return messageEnd;
    }

    public MessageSort getMessageSort() {
        return messageSort;
    }

    public void setMessageSort(MessageSort messageSort) {
        this.messageSort = messageSort;
    }

    public String getSignature() {
        StringBuilder sb = new StringBuilder();
        if (this.messageSort == MessageSort.synchCall) {
            sb.append(name);
            // 引数
            sb.append("(");
            sb.append(parameterListToSignateru());
            sb.append(")");
            // 戻り値の型
            if (Objects.nonNull(replyType)) {
                sb.append(String.format(" : %s\n", replyType.getName()));
            }
        } else if (this.messageSort == MessageSort.createMessage) {
            if (parameterList.size() == 0) {
                sb.append("<<create>>");
            } else {
                sb.append("create");
                // 引数
                sb.append("(");
                sb.append(parameterListToSignateru());
                sb.append(")");
                // 戻り値の型
                if (Objects.nonNull(replyType)) {
                    sb.append(String.format(" : %s\n", replyType.getName()));
                }
            }
        }
        return sb.toString();
    }

    private String parameterListToSignateru() {
        StringBuilder sb = new StringBuilder();
        if (parameterList.size() > 0) {
            for (Parameter parameter : parameterList) {
                sb.append(parameter.getName());
                try {
                    sb.append(String.format(" : %s", parameter.getType()));
                } catch (Exception e) {
                }
                if (parameterList.indexOf(parameter) < parameterList.size() - 1) {
                    sb.append(", ");
                }
            }
        }
        return sb.toString();
    }

    @Override
    public String toString() {
        return getSignature();
    }
}

DEBUG: Updating diagram for file: Message.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import java.util.*;

public class Relationship {
    public enum RelationType {
        INHERITANCE,
        AGGREGATION,
        COMPOSITION,
        DEPENDENCY,
        ASSOCIATION
    }

    private final String source;
    private final String target;
    private final RelationType type;
    private final String sourceRole;
    private final String targetRole;
    private final String sourceMultiplicity;
    private final String targetMultiplicity;
    private final boolean isNavigable;

    public Relationship(String source, String target, RelationType type,
            String sourceRole, String targetRole,
            String sourceMultiplicity, String targetMultiplicity,
            boolean isNavigable) {
        this.source = source;
        this.target = target;
        this.type = type;
        this.sourceRole = sourceRole;
        this.targetRole = targetRole;
        this.sourceMultiplicity = sourceMultiplicity;
        this.targetMultiplicity = targetMultiplicity;
        this.isNavigable = isNavigable;
    }

    // Getters
    public String getSource() {
        return source;
    }

    public String getTarget() {
        return target;
    }

    public RelationType getType() {
        return type;
    }

    public String getSourceRole() {
        return sourceRole;
    }

    public String getTargetRole() {
        return targetRole;
    }

    public String getSourceMultiplicity() {
        return sourceMultiplicity;
    }

    public String getTargetMultiplicity() {
        return targetMultiplicity;
    }

    public boolean isNavigable() {
        return isNavigable;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (!(o instanceof Relationship))
            return false;
        Relationship that = (Relationship) o;
        return isNavigable == that.isNavigable &&
                Objects.equals(source, that.source) &&
                Objects.equals(target, that.target) &&
                type == that.type &&
                Objects.equals(sourceRole, that.sourceRole) &&
                Objects.equals(targetRole, that.targetRole) &&
                Objects.equals(sourceMultiplicity, that.sourceMultiplicity) &&
                Objects.equals(targetMultiplicity, that.targetMultiplicity);
    }

    @Override
    public int hashCode() {
        return Objects.hash(source, target, type, sourceRole, targetRole,
                sourceMultiplicity, targetMultiplicity, isNavigable);
    }
}
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

public enum InteractionOperandKind {
    opt, alt, loop, BREAK, undefined
}

DEBUG: Updated UML classes: 0
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml;

public enum InteractionOperandKind {

    opt, alt, loop, BREAK, undefined
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.parameter.Parameter;
import io.github.morichan.fescue.feature.type.Type;
import java.util.ArrayList;
import java.util.Objects;

public class Message {

    private String name = "";

    private ArrayList<Parameter> parameterList = new ArrayList<>();

    private Type replyType;

    private OccurenceSpecification messageEnd;

    private MessageSort messageSort = MessageSort.synchCall;

    public Message(String name, OccurenceSpecification messageEnd) {
        this.name = name;
        this.messageEnd = messageEnd;
    }

    public String getName() {
        return name;
    }

    public ArrayList<Parameter> getParameterList() {
        return parameterList;
    }

    public void setParameterList(ArrayList<Parameter> parameterList) {
        this.parameterList = parameterList;
    }

    public Type getReplyType() {
        return replyType;
    }

    public OccurenceSpecification getMessageEnd() {
        return messageEnd;
    }

    public MessageSort getMessageSort() {
        return messageSort;
    }

    public void setMessageSort(MessageSort messageSort) {
        this.messageSort = messageSort;
    }

    public String getSignature() {
        StringBuilder sb = new StringBuilder();
        if (this.messageSort == MessageSort.synchCall) {
            sb.append(name);
            // 引数
            sb.append("(");
            sb.append(parameterListToSignateru());
            sb.append(")");
            // 戻り値の型
            if (Objects.nonNull(replyType)) {
                sb.append(String.format(" : %s\n", replyType.getName()));
            }
        } else if (this.messageSort == MessageSort.createMessage) {
            if (parameterList.size() == 0) {
                sb.append("<<create>>");
            } else {
                sb.append("create");
                // 引数
                sb.append("(");
                sb.append(parameterListToSignateru());
                sb.append(")");
                // 戻り値の型
                if (Objects.nonNull(replyType)) {
                    sb.append(String.format(" : %s\n", replyType.getName()));
                }
            }
        }
        return sb.toString();
    }

    private String parameterListToSignateru() {
        StringBuilder sb = new StringBuilder();
        if (parameterList.size() > 0) {
            for (Parameter parameter : parameterList) {
                sb.append(parameter.getName());
                try {
                    sb.append(String.format(" : %s", parameter.getType()));
                } catch (Exception e) {
                }
                if (parameterList.indexOf(parameter) < parameterList.size() - 1) {
                    sb.append(", ");
                }
            }
        }
        return sb.toString();
    }

    @Override
    public String toString() {
        return getSignature();
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: Message
DEBUG: Attributes: 5
DEBUG: Operations: 10
DEBUG: Updating diagram for file: Message.java
DEBUG: Updating diagram for file: InteractionOperandKind.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

public class Lifeline {
    private String name = "";
    private String type = "";

    public Lifeline(String name, String type) {
        this.name = name;
        this.type = type;
    }

    public Lifeline(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getType() {
        return type;
    }

    public String getSignature() {
        StringBuilder sb = new StringBuilder();
        if(!name.isEmpty()) {
            sb.append(name);
        }
        if(!type.isEmpty()) {
            sb.append(":" + type);
        }
        return sb.toString();
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: Lifeline
DEBUG: Attributes: 2
DEBUG: Operations: 3
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml;

public class Lifeline {

    private String name = "";

    private String type = "";

    public Lifeline(String name, String type) {
        this.name = name;
        this.type = type;
    }

    public Lifeline(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getType() {
        return type;
    }

    public String getSignature() {
        StringBuilder sb = new StringBuilder();
        if (!name.isEmpty()) {
            sb.append(name);
        }
        if (!type.isEmpty()) {
            sb.append(":" + type);
        }
        return sb.toString();
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

public enum InteractionOperandKind {

    opt, alt, loop, BREAK, undefined
}

DEBUG: Updated UML classes: 0
DEBUG: Updating diagram for file: InteractionOperandKind.java
DEBUG: Updating diagram for file: Lifeline.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

public enum MessageSort {
    synchCall, createMessage, replay
}

DEBUG: Updated UML classes: 0
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml;

public enum MessageSort {

    synchCall, createMessage, replay
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

public class Lifeline {

    private String name = "";

    private String type = "";

    public Lifeline(String name, String type) {
        this.name = name;
        this.type = type;
    }

    public Lifeline(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public String getType() {
        return type;
    }

    public String getSignature() {
        StringBuilder sb = new StringBuilder();
        if (!name.isEmpty()) {
            sb.append(name);
        }
        if (!type.isEmpty()) {
            sb.append(":" + type);
        }
        return sb.toString();
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: Lifeline
DEBUG: Attributes: 2
DEBUG: Operations: 3
DEBUG: Updating diagram for file: Lifeline.java
DEBUG: Updating diagram for file: MessageSort.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.parameter.Parameter;

import java.util.ArrayList;
import java.util.List;

public class InteractionUse extends InteractionFragment {
    private String collaborationUse = "";
    private String interactionName = "";
    private List<Parameter> parameterList = new ArrayList<>();

    public InteractionUse(Lifeline lifeline, String interactionName) {
        super.setLifeline(lifeline);
        this.interactionName = interactionName;
    }

    public String getCollaborationUse() {
        return collaborationUse;
    }

    public String getInteractionName() {
        return interactionName;
    }

    public List<Parameter> getParameterList() {
        return parameterList;
    }

    public void setCollaborationUse(String collaborationUse) {
        this.collaborationUse = collaborationUse;
    }

    public String getSignature() {
        StringBuilder sb = new StringBuilder();
        if(collaborationUse.length() > 0) {
            sb.append(collaborationUse + ".");
        }
        sb.append(interactionName);
        // 引数
        sb.append("(");
        sb.append(parameterListToSignateru());
        sb.append(")");

        return sb.toString();
    }

    private String parameterListToSignateru() {
        StringBuilder sb = new StringBuilder();

        if(parameterList.size() > 0) {
            for(Parameter parameter : parameterList) {
                sb.append(parameter.getName());
                try {
                    sb.append(String.format(" : %s", parameter.getType()));
                } catch (Exception e) {

                }
                if(parameterList.indexOf(parameter) < parameterList.size() - 1) {
                    sb.append(", ");
                }
            }
        }

        return sb.toString();
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: InteractionUse
DEBUG: Attributes: 3
DEBUG: Operations: 6
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.parameter.Parameter;
import java.util.ArrayList;
import java.util.List;

public class InteractionUse extends InteractionFragment {

    private String collaborationUse = "";

    private String interactionName = "";

    private List<Parameter> parameterList = new ArrayList<>();

    public InteractionUse(Lifeline lifeline, String interactionName) {
        super.setLifeline(lifeline);
        this.interactionName = interactionName;
    }

    public String getCollaborationUse() {
        return collaborationUse;
    }

    public String getInteractionName() {
        return interactionName;
    }

    public List<Parameter> getParameterList() {
        return parameterList;
    }

    public void setCollaborationUse(String collaborationUse) {
        this.collaborationUse = collaborationUse;
    }

    public String getSignature() {
        StringBuilder sb = new StringBuilder();
        if (collaborationUse.length() > 0) {
            sb.append(collaborationUse + ".");
        }
        sb.append(interactionName);
        // 引数
        sb.append("(");
        sb.append(parameterListToSignateru());
        sb.append(")");
        return sb.toString();
    }

    private String parameterListToSignateru() {
        StringBuilder sb = new StringBuilder();
        if (parameterList.size() > 0) {
            for (Parameter parameter : parameterList) {
                sb.append(parameter.getName());
                try {
                    sb.append(String.format(" : %s", parameter.getType()));
                } catch (Exception e) {
                }
                if (parameterList.indexOf(parameter) < parameterList.size() - 1) {
                    sb.append(", ");
                }
            }
        }
        return sb.toString();
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

public enum MessageSort {

    synchCall, createMessage, replay
}

DEBUG: Updated UML classes: 0
DEBUG: Updating diagram for file: MessageSort.java
DEBUG: Updating diagram for file: InteractionUse.java
DEBUG: Updating Java diagrams
DEBUG: Java diagrams update completed
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import com.github.javaparser.ast.stmt.Statement;

import java.util.Objects;
import java.util.Optional;

public class OccurenceSpecification extends InteractionFragment {
    private Message message;
    private Statement statement;

    public OccurenceSpecification(Lifeline lifeline) {
        super.setLifeline(lifeline);
    }

    public Message getMessage() {
        return message;
    }

    public void setMessage(Message message) {
        this.message = message;
    }

    public Optional<Statement> getStatement() {
        return Optional.ofNullable(statement);
    }

    public void setStatement(Statement statement) {
        this.statement = statement;
    }

    @Override
    public String toString() {
        if(Objects.nonNull(this.message)) {
            return message.toString();
        }
        return super.toString();
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: OccurenceSpecification
DEBUG: Attributes: 2
DEBUG: Operations: 5
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml;

import com.github.javaparser.ast.stmt.Statement;
import java.util.Objects;
import java.util.Optional;

public class OccurenceSpecification extends InteractionFragment {

    private Message message;

    private Statement statement;

    public OccurenceSpecification(Lifeline lifeline) {
        super.setLifeline(lifeline);
    }

    public Message getMessage() {
        return message;
    }

    public void setMessage(Message message) {
        this.message = message;
    }

    public Optional<Statement> getStatement() {
        return Optional.ofNullable(statement);
    }

    public void setStatement(Statement statement) {
        this.statement = statement;
    }

    @Override
    public String toString() {
        if (Objects.nonNull(this.message)) {
            return message.toString();
        }
        return super.toString();
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.parameter.Parameter;
import java.util.ArrayList;
import java.util.List;

public class InteractionUse extends InteractionFragment {

    private String collaborationUse = "";

    private String interactionName = "";

    private List<Parameter> parameterList = new ArrayList<>();

    public InteractionUse(Lifeline lifeline, String interactionName) {
        super.setLifeline(lifeline);
        this.interactionName = interactionName;
    }

    public String getCollaborationUse() {
        return collaborationUse;
    }

    public String getInteractionName() {
        return interactionName;
    }

    public List<Parameter> getParameterList() {
        return parameterList;
    }

    public void setCollaborationUse(String collaborationUse) {
        this.collaborationUse = collaborationUse;
    }

    public String getSignature() {
        StringBuilder sb = new StringBuilder();
        if (collaborationUse.length() > 0) {
            sb.append(collaborationUse + ".");
        }
        sb.append(interactionName);
        // 引数
        sb.append("(");
        sb.append(parameterListToSignateru());
        sb.append(")");
        return sb.toString();
    }

    private String parameterListToSignateru() {
        StringBuilder sb = new StringBuilder();
        if (parameterList.size() > 0) {
            for (Parameter parameter : parameterList) {
                sb.append(parameter.getName());
                try {
                    sb.append(String.format(" : %s", parameter.getType()));
                } catch (Exception e) {
                }
                if (parameterList.indexOf(parameter) < parameterList.size() - 1) {
                    sb.append(", ");
                }
            }
        }
        return sb.toString();
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: InteractionUse
DEBUG: Attributes: 3
DEBUG: Operations: 6
DEBUG: Updating diagram for file: InteractionUse.java
DEBUG: Updating diagram for file: OccurenceSpecification.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

public class InteractionOperand extends InteractionFragment {
    private String guard = "";

    public InteractionOperand(Lifeline lifeline, String guard) {
        super.setLifeline(lifeline);
        this.guard = guard;
    }

    public String getGuard() {
        return guard;
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: InteractionOperand
DEBUG: Attributes: 1
DEBUG: Operations: 1
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml;

public class InteractionOperand extends InteractionFragment {

    private String guard = "";

    public InteractionOperand(Lifeline lifeline, String guard) {
        super.setLifeline(lifeline);
        this.guard = guard;
    }

    public String getGuard() {
        return guard;
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import com.github.javaparser.ast.stmt.Statement;
import java.util.Objects;
import java.util.Optional;

public class OccurenceSpecification extends InteractionFragment {

    private Message message;

    private Statement statement;

    public OccurenceSpecification(Lifeline lifeline) {
        super.setLifeline(lifeline);
    }

    public Message getMessage() {
        return message;
    }

    public void setMessage(Message message) {
        this.message = message;
    }

    public Optional<Statement> getStatement() {
        return Optional.ofNullable(statement);
    }

    public void setStatement(Statement statement) {
        this.statement = statement;
    }

    @Override
    public String toString() {
        if (Objects.nonNull(this.message)) {
            return message.toString();
        }
        return super.toString();
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: OccurenceSpecification
DEBUG: Attributes: 2
DEBUG: Operations: 5
DEBUG: Updating diagram for file: OccurenceSpecification.java
DEBUG: Updating diagram for file: InteractionOperand.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.Attribute;
import io.github.morichan.fescue.feature.Operation;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

public class Class {
    private String name = "";
    private Boolean isAbstruct = false;
    private Boolean isActive;   // 宣言されてたかどうか
    private Class superClass;
    private List<Attribute> attributeList = new ArrayList<>();
    private List<Operation> operationList = new ArrayList<>();
    private List<Interaction> interactionList = new ArrayList<>();

    public Class(String name) {
        this.name = name;
        this.isActive = true;
    }

    public Class(String name, Boolean isActive) {
        this.name = name;
        this.isActive = isActive;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Boolean getAbstruct() {
        return isAbstruct;
    }

    public void setAbstruct(Boolean abstruct) {
        isAbstruct = abstruct;
    }

    public Boolean getActive() {
        return isActive;
    }

    public void setActive(Boolean active) {
        isActive = active;
    }

    public Optional<Class> getSuperClass() {
        return Optional.ofNullable(superClass);
    }

    public void setSuperClass(Class superClass) {
        this.superClass = superClass;
    }

    public List<Attribute> getAttributeList() {
        return Collections.unmodifiableList(attributeList);
    }

    public List<Operation> getOperationList() {
        return Collections.unmodifiableList(operationList);
    }

    public List<Interaction> getInteractionList() { return Collections.unmodifiableList(interactionList); }

    public void addAttribute(Attribute attribute) {
        attributeList.add(attribute);
    }

    public void addOperation(Operation operation) {
        operationList.add(operation);
        addInteraction(new Interaction(operation, operation.toString()));
    }

    public void addOperation(Operation operation, Interaction interaction) {
        operationList.add(operation);
        addInteraction(interaction);
    }

    public void addInteraction(Interaction interaction) {
        interactionList.add(interaction);
    }

    public void removeAttribute(Attribute attribute) {
        attributeList.remove(attribute);
    }

    public void removeOperation(Operation operation) {
        operationList.remove(operation);
        for(Interaction interaction : interactionList) {
            if(operation.equals(interaction.getOperation())) {
                removeInteraction(interaction);
                return;
            }
        }
    }

    public void removeInteraction(Interaction interaction) { interactionList.remove(interaction); }

    public Optional<Operation> findOperation(String operationId) {
        for(Operation operation : operationList) {
            if(operation.toString().equals(operationId)) {
                return Optional.of(operation);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(Operation operation) {
        for(Interaction interaction : interactionList) {
            if(interaction.getOperation().equals(operation)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(String operationName) {
        // 同じ名前のInteractionが複数あるとダメ
        for(Interaction interaction : interactionList) {
            if(interaction.getOperation().getName().getNameText().equals(operationName)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    @Override
    public String toString() {
        return this.name;
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: Class
DEBUG: Attributes: 7
DEBUG: Operations: 22
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.Attribute;
import io.github.morichan.fescue.feature.Operation;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

public class Class {

    private String name = "";

    private Boolean isAbstruct = false;

    // 宣言されてたかどうか
    private Boolean isActive;

    private Class superClass;

    private List<Attribute> attributeList = new ArrayList<>();

    private List<Operation> operationList = new ArrayList<>();

    private List<Interaction> interactionList = new ArrayList<>();

    public Class(String name) {
        this.name = name;
        this.isActive = true;
    }

    public Class(String name, Boolean isActive) {
        this.name = name;
        this.isActive = isActive;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Boolean getAbstruct() {
        return isAbstruct;
    }

    public void setAbstruct(Boolean abstruct) {
        isAbstruct = abstruct;
    }

    public Boolean getActive() {
        return isActive;
    }

    public void setActive(Boolean active) {
        isActive = active;
    }

    public Optional<Class> getSuperClass() {
        return Optional.ofNullable(superClass);
    }

    public void setSuperClass(Class superClass) {
        this.superClass = superClass;
    }

    public List<Attribute> getAttributeList() {
        return Collections.unmodifiableList(attributeList);
    }

    public List<Operation> getOperationList() {
        return Collections.unmodifiableList(operationList);
    }

    public List<Interaction> getInteractionList() {
        return Collections.unmodifiableList(interactionList);
    }

    public void addAttribute(Attribute attribute) {
        attributeList.add(attribute);
    }

    public void addOperation(Operation operation) {
        operationList.add(operation);
        addInteraction(new Interaction(operation, operation.toString()));
    }

    public void addOperation(Operation operation, Interaction interaction) {
        operationList.add(operation);
        addInteraction(interaction);
    }

    public void addInteraction(Interaction interaction) {
        interactionList.add(interaction);
    }

    public void removeAttribute(Attribute attribute) {
        attributeList.remove(attribute);
    }

    public void removeOperation(Operation operation) {
        operationList.remove(operation);
        for (Interaction interaction : interactionList) {
            if (operation.equals(interaction.getOperation())) {
                removeInteraction(interaction);
                return;
            }
        }
    }

    public void removeInteraction(Interaction interaction) {
        interactionList.remove(interaction);
    }

    public Optional<Operation> findOperation(String operationId) {
        for (Operation operation : operationList) {
            if (operation.toString().equals(operationId)) {
                return Optional.of(operation);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(Operation operation) {
        for (Interaction interaction : interactionList) {
            if (interaction.getOperation().equals(operation)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(String operationName) {
        // 同じ名前のInteractionが複数あるとダメ
        for (Interaction interaction : interactionList) {
            if (interaction.getOperation().getName().getNameText().equals(operationName)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    @Override
    public String toString() {
        return this.name;
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

public class InteractionOperand extends InteractionFragment {

    private String guard = "";

    public InteractionOperand(Lifeline lifeline, String guard) {
        super.setLifeline(lifeline);
        this.guard = guard;
    }

    public String getGuard() {
        return guard;
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: InteractionOperand
DEBUG: Attributes: 1
DEBUG: Operations: 1
DEBUG: Updating diagram for file: InteractionOperand.java
DEBUG: Updating diagram for file: Class.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import java.util.ArrayList;

public abstract class InteractionFragment {
    private Lifeline lifeline;
    private ArrayList<InteractionFragment> interactionFragmentList = new ArrayList<>();

    public Lifeline getLifeline() {
        return lifeline;
    }

    public void setLifeline(Lifeline lifeline) {
        this.lifeline = lifeline;
    }

    public ArrayList<InteractionFragment> getInteractionFragmentList() {
        return interactionFragmentList;
    }

    public void setInteractionFragmentList(ArrayList<InteractionFragment> interactionFragmentList) {
        this.interactionFragmentList = interactionFragmentList;
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: InteractionFragment
DEBUG: Attributes: 2
DEBUG: Operations: 4
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml;

import java.util.ArrayList;

public abstract class InteractionFragment {

    private Lifeline lifeline;

    private ArrayList<InteractionFragment> interactionFragmentList = new ArrayList<>();

    public Lifeline getLifeline() {
        return lifeline;
    }

    public void setLifeline(Lifeline lifeline) {
        this.lifeline = lifeline;
    }

    public ArrayList<InteractionFragment> getInteractionFragmentList() {
        return interactionFragmentList;
    }

    public void setInteractionFragmentList(ArrayList<InteractionFragment> interactionFragmentList) {
        this.interactionFragmentList = interactionFragmentList;
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.Attribute;
import io.github.morichan.fescue.feature.Operation;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

public class Class {

    private String name = "";

    private Boolean isAbstruct = false;

    // 宣言されてたかどうか
    private Boolean isActive;

    private Class superClass;

    private List<Attribute> attributeList = new ArrayList<>();

    private List<Operation> operationList = new ArrayList<>();

    private List<Interaction> interactionList = new ArrayList<>();

    public Class(String name) {
        this.name = name;
        this.isActive = true;
    }

    public Class(String name, Boolean isActive) {
        this.name = name;
        this.isActive = isActive;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Boolean getAbstruct() {
        return isAbstruct;
    }

    public void setAbstruct(Boolean abstruct) {
        isAbstruct = abstruct;
    }

    public Boolean getActive() {
        return isActive;
    }

    public void setActive(Boolean active) {
        isActive = active;
    }

    public Optional<Class> getSuperClass() {
        return Optional.ofNullable(superClass);
    }

    public void setSuperClass(Class superClass) {
        this.superClass = superClass;
    }

    public List<Attribute> getAttributeList() {
        return Collections.unmodifiableList(attributeList);
    }

    public List<Operation> getOperationList() {
        return Collections.unmodifiableList(operationList);
    }

    public List<Interaction> getInteractionList() {
        return Collections.unmodifiableList(interactionList);
    }

    public void addAttribute(Attribute attribute) {
        attributeList.add(attribute);
    }

    public void addOperation(Operation operation) {
        operationList.add(operation);
        addInteraction(new Interaction(operation, operation.toString()));
    }

    public void addOperation(Operation operation, Interaction interaction) {
        operationList.add(operation);
        addInteraction(interaction);
    }

    public void addInteraction(Interaction interaction) {
        interactionList.add(interaction);
    }

    public void removeAttribute(Attribute attribute) {
        attributeList.remove(attribute);
    }

    public void removeOperation(Operation operation) {
        operationList.remove(operation);
        for (Interaction interaction : interactionList) {
            if (operation.equals(interaction.getOperation())) {
                removeInteraction(interaction);
                return;
            }
        }
    }

    public void removeInteraction(Interaction interaction) {
        interactionList.remove(interaction);
    }

    public Optional<Operation> findOperation(String operationId) {
        for (Operation operation : operationList) {
            if (operation.toString().equals(operationId)) {
                return Optional.of(operation);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(Operation operation) {
        for (Interaction interaction : interactionList) {
            if (interaction.getOperation().equals(operation)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    public Optional<Interaction> findInteraction(String operationName) {
        // 同じ名前のInteractionが複数あるとダメ
        for (Interaction interaction : interactionList) {
            if (interaction.getOperation().getName().getNameText().equals(operationName)) {
                return Optional.of(interaction);
            }
        }
        return Optional.empty();
    }

    @Override
    public String toString() {
        return this.name;
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: Class
DEBUG: Attributes: 7
DEBUG: Operations: 22
DEBUG: Updating diagram for file: Class.java
DEBUG: Updating diagram for file: InteractionFragment.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import com.github.javaparser.ast.stmt.Statement;

import java.util.ArrayList;
import java.util.Optional;

public class CombinedFragment extends InteractionFragment{
    private InteractionOperandKind kind;
    private ArrayList<InteractionOperand> interactionOperandList = new ArrayList<>();
    private Statement statement;

    public CombinedFragment(Lifeline lifeline, InteractionOperandKind kind) {
        super.setLifeline(lifeline);
        this.kind = kind;
    }

    public InteractionOperandKind getKind() {
        return kind;
    }

    public ArrayList<InteractionOperand> getInteractionOperandList() {
        return interactionOperandList;
    }

    public Optional<Statement> getStatement() {
        return Optional.ofNullable(statement);
    }

    public void setStatement(Statement statement) {
        this.statement = statement;
    }

    @Override
    public String toString() {
        return "Combined Fragment : " + kind.toString();
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: CombinedFragment
DEBUG: Attributes: 3
DEBUG: Operations: 5
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml;

import com.github.javaparser.ast.stmt.Statement;
import java.util.ArrayList;
import java.util.Optional;

public class CombinedFragment extends InteractionFragment {

    private InteractionOperandKind kind;

    private ArrayList<InteractionOperand> interactionOperandList = new ArrayList<>();

    private Statement statement;

    public CombinedFragment(Lifeline lifeline, InteractionOperandKind kind) {
        super.setLifeline(lifeline);
        this.kind = kind;
    }

    public InteractionOperandKind getKind() {
        return kind;
    }

    public ArrayList<InteractionOperand> getInteractionOperandList() {
        return interactionOperandList;
    }

    public Optional<Statement> getStatement() {
        return Optional.ofNullable(statement);
    }

    public void setStatement(Statement statement) {
        this.statement = statement;
    }

    @Override
    public String toString() {
        return "Combined Fragment : " + kind.toString();
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import java.util.ArrayList;

public abstract class InteractionFragment {

    private Lifeline lifeline;

    private ArrayList<InteractionFragment> interactionFragmentList = new ArrayList<>();

    public Lifeline getLifeline() {
        return lifeline;
    }

    public void setLifeline(Lifeline lifeline) {
        this.lifeline = lifeline;
    }

    public ArrayList<InteractionFragment> getInteractionFragmentList() {
        return interactionFragmentList;
    }

    public void setInteractionFragmentList(ArrayList<InteractionFragment> interactionFragmentList) {
        this.interactionFragmentList = interactionFragmentList;
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: InteractionFragment
DEBUG: Attributes: 2
DEBUG: Operations: 4
DEBUG: Updating diagram for file: InteractionFragment.java
DEBUG: Updating diagram for file: CombinedFragment.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.Operation;

import java.util.ArrayList;

public class Interaction {
    private Operation operation;
    private String name = "";
    private ArrayList<InteractionFragment> interactionFragmentList = new ArrayList<>();

    public Interaction(Operation operation, String name) {
        this.operation = operation;
        this.name = name;
    }

    public Operation getOperation() {
        return operation;
    }

    public String getName() {
        return name;
    }

    public ArrayList<InteractionFragment> getInteractionFragmentList() {
        return interactionFragmentList;
    }

    public void deleteInteractionFragment(InteractionFragment targetIf) {
        delete(targetIf, interactionFragmentList);
    }

    private boolean delete(InteractionFragment targetIf, ArrayList<InteractionFragment> ifList) {
        if(ifList.remove(targetIf)) {
            return true;
        }

        for(InteractionFragment interactionFragment : ifList) {
            if(interactionFragment instanceof CombinedFragment) {
                CombinedFragment cf = (CombinedFragment)interactionFragment;
                for(InteractionOperand interactionOperand : cf.getInteractionOperandList()) {
                    if(delete(targetIf, interactionOperand.getInteractionFragmentList())) {
                        return true;
                    }
                }

            }
        }

        return false;
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: Interaction
DEBUG: Attributes: 3
DEBUG: Operations: 5
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.Operation;
import java.util.ArrayList;

public class Interaction {

    private Operation operation;

    private String name = "";

    private ArrayList<InteractionFragment> interactionFragmentList = new ArrayList<>();

    public Interaction(Operation operation, String name) {
        this.operation = operation;
        this.name = name;
    }

    public Operation getOperation() {
        return operation;
    }

    public String getName() {
        return name;
    }

    public ArrayList<InteractionFragment> getInteractionFragmentList() {
        return interactionFragmentList;
    }

    public void deleteInteractionFragment(InteractionFragment targetIf) {
        delete(targetIf, interactionFragmentList);
    }

    private boolean delete(InteractionFragment targetIf, ArrayList<InteractionFragment> ifList) {
        if (ifList.remove(targetIf)) {
            return true;
        }
        for (InteractionFragment interactionFragment : ifList) {
            if (interactionFragment instanceof CombinedFragment) {
                CombinedFragment cf = (CombinedFragment) interactionFragment;
                for (InteractionOperand interactionOperand : cf.getInteractionOperandList()) {
                    if (delete(targetIf, interactionOperand.getInteractionFragmentList())) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import com.github.javaparser.ast.stmt.Statement;
import java.util.ArrayList;
import java.util.Optional;

public class CombinedFragment extends InteractionFragment {

    private InteractionOperandKind kind;

    private ArrayList<InteractionOperand> interactionOperandList = new ArrayList<>();

    private Statement statement;

    public CombinedFragment(Lifeline lifeline, InteractionOperandKind kind) {
        super.setLifeline(lifeline);
        this.kind = kind;
    }

    public InteractionOperandKind getKind() {
        return kind;
    }

    public ArrayList<InteractionOperand> getInteractionOperandList() {
        return interactionOperandList;
    }

    public Optional<Statement> getStatement() {
        return Optional.ofNullable(statement);
    }

    public void setStatement(Statement statement) {
        this.statement = statement;
    }

    @Override
    public String toString() {
        return "Combined Fragment : " + kind.toString();
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: CombinedFragment
DEBUG: Attributes: 3
DEBUG: Operations: 5
DEBUG: Updating diagram for file: CombinedFragment.java
DEBUG: Updating diagram for file: Interaction.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

public enum ElementType {
    ATTRIBUTE("member", ""), // メンバ変数
    OPERATION("method", "()"), // メソッド
    PARAMETER("param", ""), // メソッド引数
    CLASS("class", "class"), // クラス自体
    LOCAL_VARIABLE("local", ""), // ローカル変数
    TEMPORARY("temp", ""), // 一時オブジェクト
    METHOD_CALL("call", "()"); // メソッド呼び出し

    private final String cppText;
    private final String plantUmlText;

    private ElementType(String cppText, String plantUmlText) {
        this.cppText = cppText;
        this.plantUmlText = plantUmlText;
    }

    public String getCppText() {
        return cppText;
    }

    public String getPlantUmlText() {
        return plantUmlText;
    }
}
DEBUG: Updated UML classes: 0
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

public enum ElementType {

    // メンバ変数
    ATTRIBUTE("member", ""),
    // メソッド
    OPERATION("method", "()"),
    // メソッド引数
    PARAMETER("param", ""),
    // クラス自体
    CLASS("class", "class"),
    // ローカル変数
    LOCAL_VARIABLE("local", ""),
    // 一時オブジェクト
    TEMPORARY("temp", ""),
    // メソッド呼び出し
    METHOD_CALL("call", "()");

    private final String cppText;

    private final String plantUmlText;

    private ElementType(String cppText, String plantUmlText) {
        this.cppText = cppText;
        this.plantUmlText = plantUmlText;
    }

    public String getCppText() {
        return cppText;
    }

    public String getPlantUmlText() {
        return plantUmlText;
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml;

import io.github.morichan.fescue.feature.Operation;
import java.util.ArrayList;

public class Interaction {

    private Operation operation;

    private String name = "";

    private ArrayList<InteractionFragment> interactionFragmentList = new ArrayList<>();

    public Interaction(Operation operation, String name) {
        this.operation = operation;
        this.name = name;
    }

    public Operation getOperation() {
        return operation;
    }

    public String getName() {
        return name;
    }

    public ArrayList<InteractionFragment> getInteractionFragmentList() {
        return interactionFragmentList;
    }

    public void deleteInteractionFragment(InteractionFragment targetIf) {
        delete(targetIf, interactionFragmentList);
    }

    private boolean delete(InteractionFragment targetIf, ArrayList<InteractionFragment> ifList) {
        if (ifList.remove(targetIf)) {
            return true;
        }
        for (InteractionFragment interactionFragment : ifList) {
            if (interactionFragment instanceof CombinedFragment) {
                CombinedFragment cf = (CombinedFragment) interactionFragment;
                for (InteractionOperand interactionOperand : cf.getInteractionOperandList()) {
                    if (delete(targetIf, interactionOperand.getInteractionFragmentList())) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: Interaction
DEBUG: Attributes: 3
DEBUG: Operations: 5
DEBUG: Updating diagram for file: Interaction.java
DEBUG: Updating diagram for file: ElementType.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

import io.github.morichan.fescue.feature.visibility.Visibility;
import java.util.*;

public class RelationshipElement {
    private final String name; // 要素の名前
    private final ElementType elemType; // 要素の種類
    private final String multiplicity; // 多重度
    private final Visibility visibility; // 可視性

    public RelationshipElement(
            String name,
            ElementType elemType,
            String multiplicity,
            Visibility visibility) {
        this.name = name;
        this.elemType = elemType;
        this.multiplicity = multiplicity;
        this.visibility = visibility;
    }

    // Getters
    public String getName() {
        return name;
    }

    public ElementType getElemType() {
        return elemType;
    }

    public String getMultiplicity() {
        return multiplicity;
    }

    public Visibility getVisibility() {
        return visibility;
    }
}
DEBUG: Updated UML classes: 1
DEBUG: Class: RelationshipElement
DEBUG: Attributes: 4
DEBUG: Operations: 4
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

import io.github.morichan.fescue.feature.visibility.Visibility;
import java.util.*;

public class RelationshipElement {

    // 要素の名前
    private final String name;

    // 要素の種類
    private final ElementType elemType;

    // 多重度
    private final String multiplicity;

    // 可視性
    private final Visibility visibility;

    public RelationshipElement(String name, ElementType elemType, String multiplicity, Visibility visibility) {
        this.name = name;
        this.elemType = elemType;
        this.multiplicity = multiplicity;
        this.visibility = visibility;
    }

    // Getters
    public String getName() {
        return name;
    }

    public ElementType getElemType() {
        return elemType;
    }

    public String getMultiplicity() {
        return multiplicity;
    }

    public Visibility getVisibility() {
        return visibility;
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

public enum ElementType {

    // メンバ変数
    ATTRIBUTE("member", ""),
    // メソッド
    OPERATION("method", "()"),
    // メソッド引数
    PARAMETER("param", ""),
    // クラス自体
    CLASS("class", "class"),
    // ローカル変数
    LOCAL_VARIABLE("local", ""),
    // 一時オブジェクト
    TEMPORARY("temp", ""),
    // メソッド呼び出し
    METHOD_CALL("call", "()");

    private final String cppText;

    private final String plantUmlText;

    private ElementType(String cppText, String plantUmlText) {
        this.cppText = cppText;
        this.plantUmlText = plantUmlText;
    }

    public String getCppText() {
        return cppText;
    }

    public String getPlantUmlText() {
        return plantUmlText;
    }
}

DEBUG: Updated UML classes: 0
DEBUG: Updating diagram for file: ElementType.java
DEBUG: Updating diagram for file: RelationshipElement.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Set;

import io.github.morichan.fescue.feature.visibility.Visibility;

public class RelationshipInfo {
    private final String targetClass;
    private RelationType type;
    private final Set<RelationshipElement> elements = new HashSet<>();

    public RelationshipInfo(String targetClass, RelationType type) {
        this.targetClass = targetClass;
        this.type = type;
    }

    // 完全版
    public void addElement(
            String name,
            ElementType elemType,
            String multiplicity,
            Visibility visibility) {
        elements.add(new RelationshipElement(
                name, elemType, multiplicity, visibility));
    }

    // ゲッターメソッド
    public String getTargetClass() {
        return targetClass;
    }

    public void setType(RelationType type) {
        this.type = type;
    }

    public RelationType getType() {
        return type;
    }

    public Set<RelationshipElement> getElements() {
        return Collections.unmodifiableSet(elements);
    }
}
DEBUG: Updated UML classes: 1
DEBUG: Class: RelationshipInfo
DEBUG: Attributes: 3
DEBUG: Operations: 5
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Set;
import io.github.morichan.fescue.feature.visibility.Visibility;

public class RelationshipInfo {

    private final String targetClass;

    private RelationType type;

    private final Set<RelationshipElement> elements = new HashSet<>();

    public RelationshipInfo(String targetClass, RelationType type) {
        this.targetClass = targetClass;
        this.type = type;
    }

    // 完全版
    public void addElement(String name, ElementType elemType, String multiplicity, Visibility visibility) {
        elements.add(new RelationshipElement(name, elemType, multiplicity, visibility));
    }

    // ゲッターメソッド
    public String getTargetClass() {
        return targetClass;
    }

    public void setType(RelationType type) {
        this.type = type;
    }

    public RelationType getType() {
        return type;
    }

    public Set<RelationshipElement> getElements() {
        return Collections.unmodifiableSet(elements);
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

import io.github.morichan.fescue.feature.visibility.Visibility;
import java.util.*;

public class RelationshipElement {

    // 要素の名前
    private final String name;

    // 要素の種類
    private final ElementType elemType;

    // 多重度
    private final String multiplicity;

    // 可視性
    private final Visibility visibility;

    public RelationshipElement(String name, ElementType elemType, String multiplicity, Visibility visibility) {
        this.name = name;
        this.elemType = elemType;
        this.multiplicity = multiplicity;
        this.visibility = visibility;
    }

    // Getters
    public String getName() {
        return name;
    }

    public ElementType getElemType() {
        return elemType;
    }

    public String getMultiplicity() {
        return multiplicity;
    }

    public Visibility getVisibility() {
        return visibility;
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: RelationshipElement
DEBUG: Attributes: 4
DEBUG: Operations: 4
DEBUG: Updating diagram for file: RelationshipElement.java
DEBUG: Updating diagram for file: RelationshipInfo.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

import java.util.Arrays;
import java.util.EnumSet;
import java.util.Set;

public enum Modifier {
    // 属性用の修飾子
    STATIC("static", "{static}", ElementType.ATTRIBUTE, ElementType.OPERATION),
    READONLY("const", "{readOnly}", ElementType.ATTRIBUTE, ElementType.OPERATION),
    VOLATILE("volatile", "{volatile}", ElementType.ATTRIBUTE),
    MUTABLE("mutable", "{mutable}", ElementType.ATTRIBUTE),
    QUERY("const;", "{query}", ElementType.OPERATION),

    // メソッド用の修飾子
    VIRTUAL("virtual", "{virtual}", ElementType.OPERATION),
    OVERRIDE("override", "<<override>>", ElementType.OPERATION),
    FINAL("final", "{final}", ElementType.OPERATION,
            ElementType.CLASS),
    ABSTRACT("abstract", "{abstract}", ElementType.CLASS, ElementType.OPERATION),
    PURE_VIRTUAL("= 0", "{abstract}", ElementType.OPERATION);

    private final String cppText;
    private final String plantUmlText;
    private final Set<ElementType> applicableTypes;

    private Modifier(String cppText, String plantUmlText, ElementType... types) {
        this.cppText = cppText;
        this.plantUmlText = plantUmlText;
        this.applicableTypes = EnumSet.copyOf(Arrays.asList(types));
    }

    public String getCppText(boolean isPureVirtual) {
        if (this == VIRTUAL && isPureVirtual) {
            return cppText + " = 0";
        }
        return cppText;
    }

    public String getPlantUmlText(boolean isPureVirtual) {
        if (this == VIRTUAL && isPureVirtual) {
            return "{abstract}";
        }
        return plantUmlText;
    }

    public boolean isApplicableTo(ElementType type) {
        return applicableTypes.contains(type);
    }
}
DEBUG: Updated UML classes: 0
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

import java.util.Arrays;
import java.util.EnumSet;
import java.util.Set;

public enum Modifier {

    // 属性用の修飾子
    STATIC("static", "{static}", ElementType.ATTRIBUTE, ElementType.OPERATION),
    READONLY("const", "{readOnly}", ElementType.ATTRIBUTE, ElementType.OPERATION),
    VOLATILE("volatile", "{volatile}", ElementType.ATTRIBUTE),
    MUTABLE("mutable", "{mutable}", ElementType.ATTRIBUTE),
    QUERY("const;", "{query}", ElementType.OPERATION),
    // メソッド用の修飾子
    VIRTUAL("virtual", "{virtual}", ElementType.OPERATION),
    OVERRIDE("override", "<<override>>", ElementType.OPERATION),
    FINAL("final", "{final}", ElementType.OPERATION, ElementType.CLASS),
    ABSTRACT("abstract", "{abstract}", ElementType.CLASS, ElementType.OPERATION),
    PURE_VIRTUAL("= 0", "{abstract}", ElementType.OPERATION);

    private final String cppText;

    private final String plantUmlText;

    private final Set<ElementType> applicableTypes;

    private Modifier(String cppText, String plantUmlText, ElementType... types) {
        this.cppText = cppText;
        this.plantUmlText = plantUmlText;
        this.applicableTypes = EnumSet.copyOf(Arrays.asList(types));
    }

    public String getCppText(boolean isPureVirtual) {
        if (this == VIRTUAL && isPureVirtual) {
            return cppText + " = 0";
        }
        return cppText;
    }

    public String getPlantUmlText(boolean isPureVirtual) {
        if (this == VIRTUAL && isPureVirtual) {
            return "{abstract}";
        }
        return plantUmlText;
    }

    public boolean isApplicableTo(ElementType type) {
        return applicableTypes.contains(type);
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

import java.util.Collections;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Set;
import io.github.morichan.fescue.feature.visibility.Visibility;

public class RelationshipInfo {

    private final String targetClass;

    private RelationType type;

    private final Set<RelationshipElement> elements = new HashSet<>();

    public RelationshipInfo(String targetClass, RelationType type) {
        this.targetClass = targetClass;
        this.type = type;
    }

    // 完全版
    public void addElement(String name, ElementType elemType, String multiplicity, Visibility visibility) {
        elements.add(new RelationshipElement(name, elemType, multiplicity, visibility));
    }

    // ゲッターメソッド
    public String getTargetClass() {
        return targetClass;
    }

    public void setType(RelationType type) {
        this.type = type;
    }

    public RelationType getType() {
        return type;
    }

    public Set<RelationshipElement> getElements() {
        return Collections.unmodifiableSet(elements);
    }
}

DEBUG: Updated UML classes: 1
DEBUG: Class: RelationshipInfo
DEBUG: Attributes: 3
DEBUG: Operations: 5
DEBUG: Updating diagram for file: RelationshipInfo.java
DEBUG: Updating diagram for file: Modifier.java
DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

public enum RelationType {
    INHERITANCE("extends", "--|>"),
    COMPOSITION("unique_ptr", "*--"),
    AGGREGATION("shared_ptr", "o--"),
    ASSOCIATION("pointer", "--"),
    DEPENDENCY_USE("use", "..>"),
    DEPENDENCY_PARAMETER("parameter", "..>"),
    DEPENDENCY_CALL("call", "..>"),
    DEPENDENCY_LOCAL("local", "..>"),
    REALIZATION("implements", "..|>");

    private final String cppText;
    private final String plantUmlText;

    private RelationType(String cppText, String plantUmlText) {
        this.cppText = cppText;
        this.plantUmlText = plantUmlText;
    }

    public String getCppText() {
        return cppText;
    }

    public String getPlantUmlText() {
        return plantUmlText;
    }

    public String getStereotype() {
        return this.cppText;
    }

    public boolean isDependency() {
        return name().startsWith("DEPENDENCY_");
    }
}
DEBUG: Updated UML classes: 0
DEBUG: get Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

public enum RelationType {

    INHERITANCE("extends", "--|>"),
    COMPOSITION("unique_ptr", "*--"),
    AGGREGATION("shared_ptr", "o--"),
    ASSOCIATION("pointer", "--"),
    DEPENDENCY_USE("use", "..>"),
    DEPENDENCY_PARAMETER("parameter", "..>"),
    DEPENDENCY_CALL("call", "..>"),
    DEPENDENCY_LOCAL("local", "..>"),
    REALIZATION("implements", "..|>");

    private final String cppText;

    private final String plantUmlText;

    private RelationType(String cppText, String plantUmlText) {
        this.cppText = cppText;
        this.plantUmlText = plantUmlText;
    }

    public String getCppText() {
        return cppText;
    }

    public String getPlantUmlText() {
        return plantUmlText;
    }

    public String getStereotype() {
        return this.cppText;
    }

    public boolean isDependency() {
        return name().startsWith("DEPENDENCY_");
    }
}

DEBUG: Updating Java code:
package io.github.morichan.retuss.model.uml.cpp.utils;

import java.util.Arrays;
import java.util.EnumSet;
import java.util.Set;

public enum Modifier {

    // 属性用の修飾子
    STATIC("static", "{static}", ElementType.ATTRIBUTE, ElementType.OPERATION),
    READONLY("const", "{readOnly}", ElementType.ATTRIBUTE, ElementType.OPERATION),
    VOLATILE("volatile", "{volatile}", ElementType.ATTRIBUTE),
    MUTABLE("mutable", "{mutable}", ElementType.ATTRIBUTE),
    QUERY("const;", "{query}", ElementType.OPERATION),
    // メソッド用の修飾子
    VIRTUAL("virtual", "{virtual}", ElementType.OPERATION),
    OVERRIDE("override", "<<override>>", ElementType.OPERATION),
    FINAL("final", "{final}", ElementType.OPERATION, ElementType.CLASS),
    ABSTRACT("abstract", "{abstract}", ElementType.CLASS, ElementType.OPERATION),
    PURE_VIRTUAL("= 0", "{abstract}", ElementType.OPERATION);

    private final String cppText;

    private final String plantUmlText;

    private final Set<ElementType> applicableTypes;

    private Modifier(String cppText, String plantUmlText, ElementType... types) {
        this.cppText = cppText;
        this.plantUmlText = plantUmlText;
        this.applicableTypes = EnumSet.copyOf(Arrays.asList(types));
    }

    public String getCppText(boolean isPureVirtual) {
        if (this == VIRTUAL && isPureVirtual) {
            return cppText + " = 0";
        }
        return cppText;
    }

    public String getPlantUmlText(boolean isPureVirtual) {
        if (this == VIRTUAL && isPureVirtual) {
            return "{abstract}";
        }
        return plantUmlText;
    }

    public boolean isApplicableTo(ElementType type) {
        return applicableTypes.contains(type);
    }
}

DEBUG: Updated UML classes: 0
DEBUG: Updating diagram for file: Modifier.java
DEBUG: Updating diagram for file: RelationType.java
DEBUG: Processing C++ file: A.h
DEBUG: Processing C++ file: A.h
DEBUG: Processing C++ file: A.h
DEBUG: Starting to draw Java class diagram
DEBUG: Updating Java sequence diagram for JavaModel.java
DEBUG: Found 16 classes to draw
Generated PlantUML:
@startuml
skinparam style strictuml
 skinparam linetype ortho
skinparam classAttributeIconSize 0
skinparam LineThickness 1.5
scale 1.0
class JavaModel { 
{field} - codeFileList : List<CodeFile> = new ArrayList<>()
{field} - translator : JavaTranslator = new JavaTranslator()
{method} + getInstance() : JavaModel
{method} # getCodeFileList() : List<? extends ICodeFile>
{method} + addNewCodeFile(fileName : String) : void
{method} + addNewUmlClass(umlClass : Class) : void
{method} + updateCodeFile(changedCodeFile : ICodeFile, code : String) : void
{method} + addAttribute(className : String, attribute : Attribute) : void
{method} + addOperation(className : String, operation : Operation) : void
{method} + addComposition(haveClassName : String, compositedClassName : String) : void
{method} + addGeneralization(generalizedClassName : String, superClassName : String) : void
{method} + delete(className : String) : void
{method} + delete(className : String, attribute : Attribute) : void
{method} + delete(className : String, operation : Operation) : void
{method} + delete(className : String, operation : Operation, interactionFragment : InteractionFragment) : void
{method} + deleteSuperClass(className : String) : void
{method} + addMessage(className : String, operation : Operation, message : Message) : void
{method} + findCodeFile(fileName : String) : Optional<CodeFile>
{method} + addCombinedFragment(className : String, operation : Operation, combinedFragment : CombinedFragment) : void
{method} # findMethodDeclaration(methodDeclarationList : List<MethodDeclaration>, operation : Operation) : Optional<MethodDeclaration>
}
JavaModel --|> AbstractJavaModel
JavaModel *--  " - model 1 " JavaModel
class CppRelationshipManager { 
{field} - relationshipsByTarget : Map<String,Set<RelationshipInfo>> = new HashMap<>()
{field} - sourceClassName : String
{method} + addRelationship(relationship : RelationshipInfo) : void
{method} + addRealization(interfaceName : String) : void
{method} + addInheritance(targetClass : String) : void
{method} + addComposition(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
{method} + addAggregation(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
{method} + addAssociation(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
{method} + getRelationshipsWith(targetClass : String) : Set<RelationshipInfo>
{method} + getAllRelationships() : Set<RelationshipInfo>
{method} + getRelationshipsOfType(type : RelationType) : Set<RelationshipInfo>
{method} + generatePlantUmlRelationships() : String
{method} - appendRegularRelationship(sb : StringBuilder, relation : RelationshipInfo) : void
{method} - appendDependencyRelationships(sb : StringBuilder, dependencyMap : Map<String,Set<RelationType>>) : void
{method} - appendInheritanceRelationships(sb : StringBuilder, inheritanceMap : Map<String,RelationshipInfo>) : void
{method} + removeRelationshipsWith(targetClass : String) : void
{method} + removeRelationshipsOfType(type : RelationType) : void
{method} + validateRelationships() : List<String>
}
class CppHeaderClass { 
{field} - name : String = ""
{field} - isAbstruct : Boolean = false
{field} - isInterface : Boolean = false
{field} - isActive : Boolean
{field} - superClasses : List<CppHeaderClass> = new ArrayList<>()
{field} - attributeList : List<Attribute> = new ArrayList<>()
{field} - operationList : List<Operation> = new ArrayList<>()
{field} - interactionList : List<Interaction> = new ArrayList<>()
{field} - memberModifiers : Map<String,Set<Modifier>> = new HashMap<>()
{method} + addMemberModifier(memberName : String, modifier : Modifier) : void
{method} + getModifiers(memberName : String) : Set<Modifier>
{method} + addRelationship(relationship : RelationshipInfo) : void
{method} + getRelationships() : Set<RelationshipInfo>
{method} + getRelationshipManager() : CppRelationshipManager
{method} + getName() : String
{method} + setName(name : String) : void
{method} + getAbstruct() : Boolean
{method} + setAbstruct(abstruct : Boolean) : void
{method} + getInterface() : Boolean
{method} + setInterface(abstruct : Boolean) : void
{method} + getActive() : Boolean
{method} + setActive(active : Boolean) : void
{method} + getSuperClasses() : List<CppHeaderClass>
{method} + setSuperClass(superClass : CppHeaderClass) : void
{method} + getAttributeList() : List<Attribute>
{method} + getOperationList() : List<Operation>
{method} + getInteractionList() : List<Interaction>
{method} + addAttribute(attribute : Attribute) : void
{method} + addOperation(operation : Operation) : void
{method} + addOperation(operation : Operation, interaction : Interaction) : void
{method} + addInteraction(interaction : Interaction) : void
{method} + removeAttribute(attribute : Attribute) : void
{method} + removeOperation(operation : Operation) : void
{method} + removeInteraction(interaction : Interaction) : void
{method} + findOperation(operationId : String) : Optional<Operation>
{method} + findInteraction(operation : Operation) : Optional<Interaction>
{method} + findInteraction(operationName : String) : Optional<Interaction>
{method} + toString() : String
}
CppHeaderClass *--  " - relationshipManager 1 " CppRelationshipManager
class CppImplClass { 
{field} - methodLocals : Map<String,List<LocalVariable>>
{field} - includes : Set<String>
{field} - usingDirectives : Set<String>
{field} - name : String
{field} - type : String
{field} - initialValue : String
{field} - modifiers : Set<Modifier>
{method} + getName() : String
{method} + getType() : String
{method} + getInitialValue() : String
{method} + getModifiers() : Set<Modifier>
{method} + addLocalVariable(methodName : String, variable : LocalVariable) : void
{method} + getLocalVariables(methodName : String) : List<LocalVariable>
{method} + clearLocalVariables() : void
{method} + addInclude(include : String) : void
{method} + getIncludes() : Set<String>
{method} + addUsingDirective(using : String) : void
{method} + getUsingDirectives() : Set<String>
{method} + addMethodCall(targetClass : String, methodName : String, callingMethod : String) : void
{method} + addTemporaryObject(targetClass : String, context : String) : void
{method} + addParameterType(targetClass : String, paramName : String, methodName : String) : void
{method} + getRelationshipManager() : CppRelationshipManager
{method} + getRelationships() : Set<RelationshipInfo>
{method} - isBuiltInType(type : String) : boolean
{method} - extractClassName(type : String) : String
{method} - extractBaseType(type : String) : String
{method} + getHeaderClass() : CppHeaderClass
}
CppImplClass *--  " - headerClass 1 " CppHeaderClass
CppImplClass *--  " - relationshipManager 1 " CppRelationshipManager
class LocalVariable { 
{field} - name : String
{field} - type : String
{field} - initialValue : String
{field} - modifiers : Set<Modifier>
{method} + getName() : String
{method} + getType() : String
{method} + getInitialValue() : String
{method} + getModifiers() : Set<Modifier>
}
class Message { 
{field} - name : String = ""
{field} - parameterList : ArrayList<Parameter> = new ArrayList<>()
{field} - replyType : Type
{field} - messageSort : MessageSort = MessageSort.synchCall
{method} + getName() : String
{method} + getParameterList() : ArrayList<Parameter>
{method} + setParameterList(parameterList : ArrayList<Parameter>) : void
{method} + getReplyType() : Type
{method} + getMessageEnd() : OccurenceSpecification
{method} + getMessageSort() : MessageSort
{method} + setMessageSort(messageSort : MessageSort) : void
{method} + getSignature() : String
{method} - parameterListToSignateru() : String
{method} + toString() : String
}
Message *--  " - messageEnd 1 " OccurenceSpecification
class Lifeline { 
{field} - name : String = ""
{field} - type : String = ""
{method} + getName() : String
{method} + getType() : String
{method} + getSignature() : String
}
class InteractionUse { 
{field} - collaborationUse : String = ""
{field} - interactionName : String = ""
{field} - parameterList : List<Parameter> = new ArrayList<>()
{method} + getCollaborationUse() : String
{method} + getInteractionName() : String
{method} + getParameterList() : List<Parameter>
{method} + setCollaborationUse(collaborationUse : String) : void
{method} + getSignature() : String
{method} - parameterListToSignateru() : String
}
InteractionUse --|> InteractionFragment
class OccurenceSpecification { 
{field} - statement : Statement
{method} + getMessage() : Message
{method} + setMessage(message : Message) : void
{method} + getStatement() : Optional<Statement>
{method} + setStatement(statement : Statement) : void
{method} + toString() : String
}
OccurenceSpecification --|> InteractionFragment
OccurenceSpecification *--  " - message 1 " Message
class InteractionOperand { 
{field} - guard : String = ""
{method} + getGuard() : String
}
InteractionOperand --|> InteractionFragment
class Class { 
{field} - name : String = ""
{field} - isAbstruct : Boolean = false
{field} - isActive : Boolean
{field} - attributeList : List<Attribute> = new ArrayList<>()
{field} - operationList : List<Operation> = new ArrayList<>()
{field} - interactionList : List<Interaction> = new ArrayList<>()
{method} + getName() : String
{method} + setName(name : String) : void
{method} + getAbstruct() : Boolean
{method} + setAbstruct(abstruct : Boolean) : void
{method} + getActive() : Boolean
{method} + setActive(active : Boolean) : void
{method} + getSuperClass() : Optional<Class>
{method} + setSuperClass(superClass : Class) : void
{method} + getAttributeList() : List<Attribute>
{method} + getOperationList() : List<Operation>
{method} + getInteractionList() : List<Interaction>
{method} + addAttribute(attribute : Attribute) : void
{method} + addOperation(operation : Operation) : void
{method} + addOperation(operation : Operation, interaction : Interaction) : void
{method} + addInteraction(interaction : Interaction) : void
{method} + removeAttribute(attribute : Attribute) : void
{method} + removeOperation(operation : Operation) : void
{method} + removeInteraction(interaction : Interaction) : void
{method} + findOperation(operationId : String) : Optional<Operation>
{method} + findInteraction(operation : Operation) : Optional<Interaction>
{method} + findInteraction(operationName : String) : Optional<Interaction>
{method} + toString() : String
}
Class *--  " - superClass 1 " Class
abstract class InteractionFragment { 
{field} - interactionFragmentList : ArrayList<InteractionFragment> = new ArrayList<>()
{method} + getLifeline() : Lifeline
{method} + setLifeline(lifeline : Lifeline) : void
{method} + getInteractionFragmentList() : ArrayList<InteractionFragment>
{method} + setInteractionFragmentList(interactionFragmentList : ArrayList<InteractionFragment>) : void
}
InteractionFragment *--  " - lifeline 1 " Lifeline
class CombinedFragment { 
{field} - kind : InteractionOperandKind
{field} - interactionOperandList : ArrayList<InteractionOperand> = new ArrayList<>()
{field} - statement : Statement
{method} + getKind() : InteractionOperandKind
{method} + getInteractionOperandList() : ArrayList<InteractionOperand>
{method} + getStatement() : Optional<Statement>
{method} + setStatement(statement : Statement) : void
{method} + toString() : String
}
CombinedFragment --|> InteractionFragment
class Interaction { 
{field} - operation : Operation
{field} - name : String = ""
{field} - interactionFragmentList : ArrayList<InteractionFragment> = new ArrayList<>()
{method} + getOperation() : Operation
{method} + getName() : String
{method} + getInteractionFragmentList() : ArrayList<InteractionFragment>
{method} + deleteInteractionFragment(targetIf : InteractionFragment) : void
{method} - delete(targetIf : InteractionFragment, ifList : ArrayList<InteractionFragment>) : boolean
}
class RelationshipElement { 
{field} - name : String
{field} - elemType : ElementType
{field} - multiplicity : String
{field} - visibility : Visibility
{method} + getName() : String
{method} + getElemType() : ElementType
{method} + getMultiplicity() : String
{method} + getVisibility() : Visibility
}
class RelationshipInfo { 
{field} - targetClass : String
{field} - type : RelationType
{field} - elements : Set<RelationshipElement> = new HashSet<>()
{method} + addElement(name : String, elemType : ElementType, multiplicity : String, visibility : Visibility) : void
{method} + getTargetClass() : String
{method} + setType(type : RelationType) : void
{method} + getType() : RelationType
{method} + getElements() : Set<RelationshipElement>
}
@enduml

DEBUG: Created new tab for JavaModel.java
DEBUG: Processing class: JavaModel
DEBUG: Found 18 operations
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + getInstance() : JavaModel
@startuml
scale 1.5
skinparam style strictuml
mainframe + getInstance() : JavaModel
[-> ":JavaModel" 
activate ":JavaModel"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: # getCodeFileList() : List<? extends ICodeFile>
@startuml
scale 1.5
skinparam style strictuml
mainframe # getCodeFileList() : List<? extends ICodeFile>
[-> ":JavaModel" 
activate ":JavaModel"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addNewCodeFile(fileName : String) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addNewCodeFile(fileName : String) : void
[-> ":JavaModel" 
activate ":JavaModel"
":JavaModel" -->> "newCodeFile:CodeFile" ** : create(fileName)
":JavaModel" -> "codeFileList:List<CodeFile>": add(newCodeFile)
activate "codeFileList:List<CodeFile>"
ref over "codeFileList:List<CodeFile>" : codeFileList.add(newCodeFile) 
":JavaModel" <<-- "codeFileList:List<CodeFile>" 
deactivate "codeFileList:List<CodeFile>"
":JavaModel" -> "codeController": updateCodeTab(newCodeFile)
activate "codeController"
ref over "codeController" : codeController.updateCodeTab(newCodeFile) 
":JavaModel" <<-- "codeController" 
deactivate "codeController"
":JavaModel" -> "umlController": updateDiagram(newCodeFile)
activate "umlController"
ref over "umlController" : umlController.updateDiagram(newCodeFile) 
":JavaModel" <<-- "umlController" 
deactivate "umlController"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addNewUmlClass(umlClass : Class) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addNewUmlClass(umlClass : Class) : void
[-> ":JavaModel" 
activate ":JavaModel"
":JavaModel" -->> "codeFile:CodeFile" ** : create(String.format("%s.java", umlClass.getName()))
":JavaModel" -> "codeFileList:List<CodeFile>": add(codeFile)
activate "codeFileList:List<CodeFile>"
ref over "codeFileList:List<CodeFile>" : codeFileList.add(codeFile) 
":JavaModel" <<-- "codeFileList:List<CodeFile>" 
deactivate "codeFileList:List<CodeFile>"
":JavaModel" -> "codeFile:CodeFile": addUmlClass(umlClass)
activate "codeFile:CodeFile"
ref over "codeFile:CodeFile" : codeFile.addUmlClass(umlClass) 
":JavaModel" <<-- "codeFile:CodeFile" 
deactivate "codeFile:CodeFile"
":JavaModel" -> "umlController": updateDiagram(codeFile)
activate "umlController"
ref over "umlController" : umlController.updateDiagram(codeFile) 
":JavaModel" <<-- "umlController" 
deactivate "umlController"
":JavaModel" -> "codeController": updateCodeTab(codeFile)
activate "codeController"
ref over "codeController" : codeController.updateCodeTab(codeFile) 
":JavaModel" <<-- "codeController" 
deactivate "codeController"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + updateCodeFile(changedCodeFile : ICodeFile, code : String) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + updateCodeFile(changedCodeFile : ICodeFile, code : String) : void
[-> ":JavaModel" 
activate ":JavaModel"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addAttribute(className : String, attribute : Attribute) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addAttribute(className : String, attribute : Attribute) : void
[-> ":JavaModel" 
activate ":JavaModel"
break targetClass.isEmpty() || targetCodeFile.isEmpty()
end
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addOperation(className : String, operation : Operation) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addOperation(className : String, operation : Operation) : void
[-> ":JavaModel" 
activate ":JavaModel"
break targetClass.isEmpty() || targetCodeFile.isEmpty()
end
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addComposition(haveClassName : String, compositedClassName : String) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addComposition(haveClassName : String, compositedClassName : String) : void
[-> ":JavaModel" 
activate ":JavaModel"
break haveCodefileOptional.isEmpty() || compositedCodefileOptional.isEmpty() || haveClassOptional.isEmpty() || compositedClassOptional.isEmpty()
end
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addGeneralization(generalizedClassName : String, superClassName : String) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addGeneralization(generalizedClassName : String, superClassName : String) : void
[-> ":JavaModel" 
activate ":JavaModel"
break generalizedCodefileOptional.isEmpty() || superCodefileOptional.isEmpty() || generalizedClassOptional.isEmpty() || superClassOptional.isEmpty()
end
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + delete(className : String) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + delete(className : String) : void
[-> ":JavaModel" 
activate ":JavaModel"
break classOptional.isEmpty() || codeFileOptional.isEmpty()
end
":JavaModel" -> "codeFileOptional.get()": removeClass(classOptional.get())
activate "codeFileOptional.get()"
ref over "codeFileOptional.get()" : codeFileOptional.get().removeClass(classOptional.get()) 
":JavaModel" <<-- "codeFileOptional.get()" 
deactivate "codeFileOptional.get()"
":JavaModel" -> "umlController": updateDiagram(codeFileOptional.get())
activate "umlController"
ref over "umlController" : umlController.updateDiagram(codeFileOptional.get()) 
":JavaModel" <<-- "umlController" 
deactivate "umlController"
":JavaModel" -> "codeController": updateCodeTab(codeFileOptional.get())
activate "codeController"
ref over "codeController" : codeController.updateCodeTab(codeFileOptional.get()) 
":JavaModel" <<-- "codeController" 
deactivate "codeController"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + delete(className : String, attribute : Attribute) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + delete(className : String, attribute : Attribute) : void
[-> ":JavaModel" 
activate ":JavaModel"
break classOptional.isEmpty() || codeFileOptional.isEmpty()
end
":JavaModel" -> "classOptional.get()": removeAttribute(attribute)
activate "classOptional.get()"
ref over "classOptional.get()" : classOptional.get().removeAttribute(attribute) 
":JavaModel" <<-- "classOptional.get()" 
deactivate "classOptional.get()"
":JavaModel" -> "classOrInterfaceDeclarationOptional.get()": remove(fieldOptional.get())
activate "classOrInterfaceDeclarationOptional.get()"
ref over "classOrInterfaceDeclarationOptional.get()" : classOrInterfaceDeclarationOptional.get().remove(fieldOptional.get()) 
":JavaModel" <<-- "classOrInterfaceDeclarationOptional.get()" 
deactivate "classOrInterfaceDeclarationOptional.get()"
":JavaModel" -> "umlController": updateDiagram(codeFileOptional.get())
activate "umlController"
ref over "umlController" : umlController.updateDiagram(codeFileOptional.get()) 
":JavaModel" <<-- "umlController" 
deactivate "umlController"
":JavaModel" -> "codeController": updateCodeTab(codeFileOptional.get())
activate "codeController"
ref over "codeController" : codeController.updateCodeTab(codeFileOptional.get()) 
":JavaModel" <<-- "codeController" 
deactivate "codeController"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + delete(className : String, operation : Operation) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + delete(className : String, operation : Operation) : void
[-> ":JavaModel" 
activate ":JavaModel"
break classOptional.isEmpty() || codeFileOptional.isEmpty()
end
break methodList.size() <= 0
end
break targetMethodOptional.isEmpty()
end
":JavaModel" -> "classOrInterfaceDeclarationOptional.get()": remove(targetMethodOptional.get())
activate "classOrInterfaceDeclarationOptional.get()"
ref over "classOrInterfaceDeclarationOptional.get()" : classOrInterfaceDeclarationOptional.get().remove(targetMethodOptional.get()) 
":JavaModel" <<-- "classOrInterfaceDeclarationOptional.get()" 
deactivate "classOrInterfaceDeclarationOptional.get()"
":JavaModel" -> "classOptional.get()": removeOperation(operation)
activate "classOptional.get()"
ref over "classOptional.get()" : classOptional.get().removeOperation(operation) 
":JavaModel" <<-- "classOptional.get()" 
deactivate "classOptional.get()"
":JavaModel" -> "umlController": updateDiagram(codeFileOptional.get())
activate "umlController"
ref over "umlController" : umlController.updateDiagram(codeFileOptional.get()) 
":JavaModel" <<-- "umlController" 
deactivate "umlController"
":JavaModel" -> "codeController": updateCodeTab(codeFileOptional.get())
activate "codeController"
ref over "codeController" : codeController.updateCodeTab(codeFileOptional.get()) 
":JavaModel" <<-- "codeController" 
deactivate "codeController"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + delete(className : String, operation : Operation, interactionFragment : InteractionFragment) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + delete(className : String, operation : Operation, interactionFragment : InteractionFragment) : void
[-> ":JavaModel" 
activate ":JavaModel"
break classOptional.isEmpty() || codeFileOptional.isEmpty()
end
break Objects.isNull(targetInteraction)
end
break methodList.size() <= 0
end
break targetMethodOptional.isEmpty() || targetMethodOptional.get().getBody().isEmpty()
end
alt interactionFragment instanceof OccurenceSpecification
else interactionFragment instanceof CombinedFragment
else else
end
break removeTargetOptional.isEmpty()
end
break !removeTargetOptional.get().remove()
end
":JavaModel" -> "targetInteraction:Interaction": deleteInteractionFragment(interactionFragment)
activate "targetInteraction:Interaction"
"targetInteraction:Interaction" -> "targetInteraction:Interaction": delete(targetIf, interactionFragmentList)
activate "targetInteraction:Interaction"
break ifList.remove(targetIf)
end
deactivate "targetInteraction:Interaction"
":JavaModel" <<-- "targetInteraction:Interaction" 
deactivate "targetInteraction:Interaction"
":JavaModel" -> "umlController": updateDiagram(codeFileOptional.get())
activate "umlController"
ref over "umlController" : umlController.updateDiagram(codeFileOptional.get()) 
":JavaModel" <<-- "umlController" 
deactivate "umlController"
":JavaModel" -> "codeController": updateCodeTab(codeFileOptional.get())
activate "codeController"
ref over "codeController" : codeController.updateCodeTab(codeFileOptional.get()) 
":JavaModel" <<-- "codeController" 
deactivate "codeController"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + deleteSuperClass(className : String) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + deleteSuperClass(className : String) : void
[-> ":JavaModel" 
activate ":JavaModel"
break classOptional.isEmpty() || codeFileOptional.isEmpty() || classOptional.get().getSuperClass().isEmpty()
end
":JavaModel" -> "classOrInterfaceDeclarationOptional.get().getExtendedTypes()": remove(0)
activate "classOrInterfaceDeclarationOptional.get().getExtendedTypes()"
ref over "classOrInterfaceDeclarationOptional.get().getExtendedTypes()" : classOrInterfaceDeclarationOptional.get().getExtendedTypes().remove(0) 
":JavaModel" <<-- "classOrInterfaceDeclarationOptional.get().getExtendedTypes()" 
deactivate "classOrInterfaceDeclarationOptional.get().getExtendedTypes()"
":JavaModel" -> "classOptional.get()": setSuperClass(null)
activate "classOptional.get()"
ref over "classOptional.get()" : classOptional.get().setSuperClass(null) 
":JavaModel" <<-- "classOptional.get()" 
deactivate "classOptional.get()"
":JavaModel" -> "umlController": updateDiagram(codeFileOptional.get())
activate "umlController"
ref over "umlController" : umlController.updateDiagram(codeFileOptional.get()) 
":JavaModel" <<-- "umlController" 
deactivate "umlController"
":JavaModel" -> "codeController": updateCodeTab(codeFileOptional.get())
activate "codeController"
ref over "codeController" : codeController.updateCodeTab(codeFileOptional.get()) 
":JavaModel" <<-- "codeController" 
deactivate "codeController"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addMessage(className : String, operation : Operation, message : Message) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addMessage(className : String, operation : Operation, message : Message) : void
[-> ":JavaModel" 
activate ":JavaModel"
break classOptional.isEmpty() || codeFileOptional.isEmpty()
end
break Objects.isNull(targetInteraction)
end
break methodDeclarationOptional.isEmpty()
end
":JavaModel" -->> "occurenceSpecification:OccurenceSpecification" ** : create(new Lifeline("", targetClass.getName()))
":JavaModel" -> "occurenceSpecification:OccurenceSpecification": setMessage(message)
activate "occurenceSpecification:OccurenceSpecification"
":JavaModel" <<-- "occurenceSpecification:OccurenceSpecification" 
deactivate "occurenceSpecification:OccurenceSpecification"
":JavaModel" -> "targetInteraction.getInteractionFragmentList()": add(occurenceSpecification)
activate "targetInteraction.getInteractionFragmentList()"
ref over "targetInteraction.getInteractionFragmentList()" : targetInteraction.getInteractionFragmentList().add(occurenceSpecification) 
":JavaModel" <<-- "targetInteraction.getInteractionFragmentList()" 
deactivate "targetInteraction.getInteractionFragmentList()"
":JavaModel" -> "body:BlockStmt": addStatement(expressionStmt)
activate "body:BlockStmt"
ref over "body:BlockStmt" : body.addStatement(expressionStmt) 
":JavaModel" <<-- "body:BlockStmt" 
deactivate "body:BlockStmt"
":JavaModel" -> "umlController": updateDiagram(codeFileOptional.get())
activate "umlController"
ref over "umlController" : umlController.updateDiagram(codeFileOptional.get()) 
":JavaModel" <<-- "umlController" 
deactivate "umlController"
":JavaModel" -> "codeController": updateCodeTab(codeFileOptional.get())
activate "codeController"
ref over "codeController" : codeController.updateCodeTab(codeFileOptional.get()) 
":JavaModel" <<-- "codeController" 
deactivate "codeController"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + findCodeFile(fileName : String) : Optional<CodeFile>
@startuml
scale 1.5
skinparam style strictuml
mainframe + findCodeFile(fileName : String) : Optional<CodeFile>
[-> ":JavaModel" 
activate ":JavaModel"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addCombinedFragment(className : String, operation : Operation, combinedFragment : CombinedFragment) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addCombinedFragment(className : String, operation : Operation, combinedFragment : CombinedFragment) : void
[-> ":JavaModel" 
activate ":JavaModel"
break classOptional.isEmpty() || codeFileOptional.isEmpty()
end
break Objects.isNull(targetInteraction)
end
break methodDeclarationOptional.isEmpty()
end
":JavaModel" -> "combinedFragment": setStatement(statement)
activate "combinedFragment"
ref over "combinedFragment" : combinedFragment.setStatement(statement) 
":JavaModel" <<-- "combinedFragment" 
deactivate "combinedFragment"
":JavaModel" -> "targetInteraction.getInteractionFragmentList()": add(combinedFragment)
activate "targetInteraction.getInteractionFragmentList()"
ref over "targetInteraction.getInteractionFragmentList()" : targetInteraction.getInteractionFragmentList().add(combinedFragment) 
":JavaModel" <<-- "targetInteraction.getInteractionFragmentList()" 
deactivate "targetInteraction.getInteractionFragmentList()"
":JavaModel" -> "body:BlockStmt": addStatement(statement)
activate "body:BlockStmt"
ref over "body:BlockStmt" : body.addStatement(statement) 
":JavaModel" <<-- "body:BlockStmt" 
deactivate "body:BlockStmt"
":JavaModel" -> "umlController": updateDiagram(codeFileOptional.get())
activate "umlController"
ref over "umlController" : umlController.updateDiagram(codeFileOptional.get()) 
":JavaModel" <<-- "umlController" 
deactivate "umlController"
":JavaModel" -> "codeController": updateCodeTab(codeFileOptional.get())
activate "codeController"
ref over "codeController" : codeController.updateCodeTab(codeFileOptional.get()) 
":JavaModel" <<-- "codeController" 
deactivate "codeController"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: # findMethodDeclaration(methodDeclarationList : List<MethodDeclaration>, operation : Operation) : Optional<MethodDeclaration>
@startuml
scale 1.5
skinparam style strictuml
mainframe # findMethodDeclaration(methodDeclarationList : List<MethodDeclaration>, operation : Operation) : Optional<MethodDeclaration>
[-> ":JavaModel" 
activate ":JavaModel"
[<<-- ":JavaModel"
deactivate ":JavaModel"
@enduml
DEBUG: Java sequence diagram update completed
DEBUG: selectedClassName = A
CppModel classes: 1
  Class: A
  Attributes: []
  Operations: [+ A(), + ~A()]
  Relations: 
DEBUG: CppClassDiagramDrawer - Number of classes: 1
Generated PlantUML:
@startuml
 skinparam linetype ortho
skinparam classAttributeIconSize 0
skinparam LineThickness 1.5
hide empty members
skinparam enumBackgroundColor White
skinparam enumBorderColor Black
scale 1.0
class A #90EE90 {
  + A()
  + {virtual} ~A()
}

@enduml

DEBUG: Updating Java sequence diagram for CppRelationshipManager.java
DEBUG: Created new tab for CppRelationshipManager.java
DEBUG: Processing class: CppRelationshipManager
DEBUG: Found 16 operations
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addRelationship(relationship : RelationshipInfo) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addRelationship(relationship : RelationshipInfo) : void
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
":CppRelationshipManager" -> "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())": add(relationship)
activate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
ref over "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" : relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>()).add(relationship) 
":CppRelationshipManager" <<-- "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" 
deactivate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: CppClassDiagramDrawer draw completed
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addRealization(interfaceName : String) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addRealization(interfaceName : String) : void
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
":CppRelationshipManager" -->> "relation:RelationshipInfo" ** : create(interfaceName, RelationType.REALIZATION)
":CppRelationshipManager" -> ":CppRelationshipManager": addRelationship(relation)
activate ":CppRelationshipManager"
":CppRelationshipManager" -> "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())": add(relationship)
activate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
ref over "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" : relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>()).add(relationship) 
":CppRelationshipManager" <<-- "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" 
deactivate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
deactivate ":CppRelationshipManager"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addInheritance(targetClass : String) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addInheritance(targetClass : String) : void
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
":CppRelationshipManager" -->> "relation:RelationshipInfo" ** : create(targetClass, RelationType.INHERITANCE)
":CppRelationshipManager" -> ":CppRelationshipManager": addRelationship(relation)
activate ":CppRelationshipManager"
":CppRelationshipManager" -> "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())": add(relationship)
activate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
ref over "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" : relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>()).add(relationship) 
":CppRelationshipManager" <<-- "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" 
deactivate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
deactivate ":CppRelationshipManager"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: CppClassDiagramDrawer draw completed
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addComposition(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addComposition(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
":CppRelationshipManager" -->> "relation:RelationshipInfo" ** : create(targetClass, RelationType.COMPOSITION)
":CppRelationshipManager" -> "relation:RelationshipInfo": addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility)
activate "relation:RelationshipInfo"
"relation:RelationshipInfo" -> "elements:Set<RelationshipElement>": add(new RelationshipElement(name, elemType, multiplicity, visibility))
activate "elements:Set<RelationshipElement>"
ref over "elements:Set<RelationshipElement>" : elements.add(new RelationshipElement(name, elemType, multiplicity, visibility)) 
"relation:RelationshipInfo" <<-- "elements:Set<RelationshipElement>" 
deactivate "elements:Set<RelationshipElement>"
":CppRelationshipManager" <<-- "relation:RelationshipInfo" 
deactivate "relation:RelationshipInfo"
":CppRelationshipManager" -> ":CppRelationshipManager": addRelationship(relation)
activate ":CppRelationshipManager"
":CppRelationshipManager" -> "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())": add(relationship)
activate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
ref over "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" : relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>()).add(relationship) 
":CppRelationshipManager" <<-- "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" 
deactivate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
deactivate ":CppRelationshipManager"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addAggregation(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addAggregation(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
":CppRelationshipManager" -->> "relation:RelationshipInfo" ** : create(targetClass, RelationType.AGGREGATION)
":CppRelationshipManager" -> "relation:RelationshipInfo": addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility)
activate "relation:RelationshipInfo"
"relation:RelationshipInfo" -> "elements:Set<RelationshipElement>": add(new RelationshipElement(name, elemType, multiplicity, visibility))
activate "elements:Set<RelationshipElement>"
ref over "elements:Set<RelationshipElement>" : elements.add(new RelationshipElement(name, elemType, multiplicity, visibility)) 
"relation:RelationshipInfo" <<-- "elements:Set<RelationshipElement>" 
deactivate "elements:Set<RelationshipElement>"
":CppRelationshipManager" <<-- "relation:RelationshipInfo" 
deactivate "relation:RelationshipInfo"
":CppRelationshipManager" -> ":CppRelationshipManager": addRelationship(relation)
activate ":CppRelationshipManager"
":CppRelationshipManager" -> "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())": add(relationship)
activate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
ref over "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" : relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>()).add(relationship) 
":CppRelationshipManager" <<-- "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" 
deactivate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
deactivate ":CppRelationshipManager"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + addAssociation(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + addAssociation(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
":CppRelationshipManager" -->> "relation:RelationshipInfo" ** : create(targetClass, RelationType.ASSOCIATION)
":CppRelationshipManager" -> "relation:RelationshipInfo": addElement(memberName, ElementType.ATTRIBUTE, multiplicity, visibility)
activate "relation:RelationshipInfo"
"relation:RelationshipInfo" -> "elements:Set<RelationshipElement>": add(new RelationshipElement(name, elemType, multiplicity, visibility))
activate "elements:Set<RelationshipElement>"
ref over "elements:Set<RelationshipElement>" : elements.add(new RelationshipElement(name, elemType, multiplicity, visibility)) 
"relation:RelationshipInfo" <<-- "elements:Set<RelationshipElement>" 
deactivate "elements:Set<RelationshipElement>"
":CppRelationshipManager" <<-- "relation:RelationshipInfo" 
deactivate "relation:RelationshipInfo"
":CppRelationshipManager" -> ":CppRelationshipManager": addRelationship(relation)
activate ":CppRelationshipManager"
":CppRelationshipManager" -> "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())": add(relationship)
activate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
ref over "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" : relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>()).add(relationship) 
":CppRelationshipManager" <<-- "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())" 
deactivate "relationshipsByTarget.computeIfAbsent(relationship.getTargetClass(), k -> new HashSet<>())"
deactivate ":CppRelationshipManager"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + getRelationshipsWith(targetClass : String) : Set<RelationshipInfo>
@startuml
scale 1.5
skinparam style strictuml
mainframe + getRelationshipsWith(targetClass : String) : Set<RelationshipInfo>
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + getAllRelationships() : Set<RelationshipInfo>
@startuml
scale 1.5
skinparam style strictuml
mainframe + getAllRelationships() : Set<RelationshipInfo>
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + getRelationshipsOfType(type : RelationType) : Set<RelationshipInfo>
@startuml
scale 1.5
skinparam style strictuml
mainframe + getRelationshipsOfType(type : RelationType) : Set<RelationshipInfo>
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + generatePlantUmlRelationships() : String
@startuml
scale 1.5
skinparam style strictuml
mainframe + generatePlantUmlRelationships() : String
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
":CppRelationshipManager" -->> "sb:StringBuilder" ** : <<create>>
":CppRelationshipManager" -->> "inheritanceMap:HashMap<>" ** : <<create>>
":CppRelationshipManager" -->> "dependencyMap:HashMap<>" ** : <<create>>
":CppRelationshipManager" -> ":CppRelationshipManager": appendDependencyRelationships(sb, dependencyMap)
activate ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
":CppRelationshipManager" -> ":CppRelationshipManager": appendInheritanceRelationships(sb, inheritanceMap)
activate ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: - appendRegularRelationship(sb : StringBuilder, relation : RelationshipInfo) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe - appendRegularRelationship(sb : StringBuilder, relation : RelationshipInfo) : void
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
":CppRelationshipManager" -> "sb.append(sourceClassName).append(" ").append(relation.getType().getPlantUmlText())": append(" \"")
activate "sb.append(sourceClassName).append(" ").append(relation.getType().getPlantUmlText())"
ref over "sb.append(sourceClassName).append(" ").append(relation.getType().getPlantUmlText())" : sb.append(sourceClassName).append(" ").append(relation.getType().getPlantUmlText()).append(" \"") 
":CppRelationshipManager" <<-- "sb.append(sourceClassName).append(" ").append(relation.getType().getPlantUmlText())" 
deactivate "sb.append(sourceClassName).append(" ").append(relation.getType().getPlantUmlText())"
opt !relation.getElements().isEmpty()
":CppRelationshipManager" -> "sb": append(elem.getMultiplicity() != null ? elem.getMultiplicity() : "1")
activate "sb"
ref over "sb" : sb.append(elem.getMultiplicity() != null ? elem.getMultiplicity() : "1") 
":CppRelationshipManager" <<-- "sb" 
deactivate "sb"
end
":CppRelationshipManager" -> "sb.append("\" ")": append(relation.getTargetClass())
activate "sb.append("\" ")"
ref over "sb.append("\" ")" : sb.append("\" ").append(relation.getTargetClass()) 
":CppRelationshipManager" <<-- "sb.append("\" ")" 
deactivate "sb.append("\" ")"
opt !relation.getElements().isEmpty()
":CppRelationshipManager" -> "sb.append(" : ").append(elem.getVisibility())": append(elem.getName())
activate "sb.append(" : ").append(elem.getVisibility())"
ref over "sb.append(" : ").append(elem.getVisibility())" : sb.append(" : ").append(elem.getVisibility()).append(elem.getName()) 
":CppRelationshipManager" <<-- "sb.append(" : ").append(elem.getVisibility())" 
deactivate "sb.append(" : ").append(elem.getVisibility())"
end
":CppRelationshipManager" -> "sb": append("\n")
activate "sb"
ref over "sb" : sb.append("\n") 
":CppRelationshipManager" <<-- "sb" 
deactivate "sb"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: - appendDependencyRelationships(sb : StringBuilder, dependencyMap : Map<String,Set<RelationType>>) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe - appendDependencyRelationships(sb : StringBuilder, dependencyMap : Map<String,Set<RelationType>>) : void
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: - appendInheritanceRelationships(sb : StringBuilder, inheritanceMap : Map<String,RelationshipInfo>) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe - appendInheritanceRelationships(sb : StringBuilder, inheritanceMap : Map<String,RelationshipInfo>) : void
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + removeRelationshipsWith(targetClass : String) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + removeRelationshipsWith(targetClass : String) : void
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
":CppRelationshipManager" -> "relationshipsByTarget:Map<String,Set<RelationshipInfo>>": remove(targetClass)
activate "relationshipsByTarget:Map<String,Set<RelationshipInfo>>"
ref over "relationshipsByTarget:Map<String,Set<RelationshipInfo>>" : relationshipsByTarget.remove(targetClass) 
":CppRelationshipManager" <<-- "relationshipsByTarget:Map<String,Set<RelationshipInfo>>" 
deactivate "relationshipsByTarget:Map<String,Set<RelationshipInfo>>"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + removeRelationshipsOfType(type : RelationType) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + removeRelationshipsOfType(type : RelationType) : void
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
":CppRelationshipManager" -> "relationshipsByTarget.values()": removeIf(relations -> relations.removeIf(relation -> relation.getType() == type))
activate "relationshipsByTarget.values()"
ref over "relationshipsByTarget.values()" : relationshipsByTarget.values().removeIf(relations -> relations.removeIf(relation -> relation.getType() == type)) 
":CppRelationshipManager" <<-- "relationshipsByTarget.values()" 
deactivate "relationshipsByTarget.values()"
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + validateRelationships() : List<String>
@startuml
scale 1.5
skinparam style strictuml
mainframe + validateRelationships() : List<String>
[-> ":CppRelationshipManager" 
activate ":CppRelationshipManager"
":CppRelationshipManager" -->> "issues:ArrayList<>" ** : <<create>>
opt inheritanceCount > 1
":CppRelationshipManager" -> "issues:List<String>": add("Multiple inheritance detected: " + inheritanceCount + " parent classes")
activate "issues:List<String>"
ref over "issues:List<String>" : issues.add("Multiple inheritance detected: " + inheritanceCount + " parent classes") 
":CppRelationshipManager" <<-- "issues:List<String>" 
deactivate "issues:List<String>"
end
[<<-- ":CppRelationshipManager"
deactivate ":CppRelationshipManager"
@enduml
DEBUG: Java sequence diagram update completed
DEBUG: Updating Java sequence diagram for InteractionUse.java
DEBUG: Created new tab for InteractionUse.java
DEBUG: Processing class: InteractionUse
DEBUG: Found 6 operations
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + getCollaborationUse() : String
@startuml
scale 1.5
skinparam style strictuml
mainframe + getCollaborationUse() : String
[-> ":InteractionUse" 
activate ":InteractionUse"
[<<-- ":InteractionUse"
deactivate ":InteractionUse"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + getInteractionName() : String
@startuml
scale 1.5
skinparam style strictuml
mainframe + getInteractionName() : String
[-> ":InteractionUse" 
activate ":InteractionUse"
[<<-- ":InteractionUse"
deactivate ":InteractionUse"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + getParameterList() : List<Parameter>
@startuml
scale 1.5
skinparam style strictuml
mainframe + getParameterList() : List<Parameter>
[-> ":InteractionUse" 
activate ":InteractionUse"
[<<-- ":InteractionUse"
deactivate ":InteractionUse"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + setCollaborationUse(collaborationUse : String) : void
@startuml
scale 1.5
skinparam style strictuml
mainframe + setCollaborationUse(collaborationUse : String) : void
[-> ":InteractionUse" 
activate ":InteractionUse"
[<<-- ":InteractionUse"
deactivate ":InteractionUse"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: + getSignature() : String
@startuml
scale 1.5
skinparam style strictuml
mainframe + getSignature() : String
[-> ":InteractionUse" 
activate ":InteractionUse"
":InteractionUse" -->> "sb:StringBuilder" ** : <<create>>
opt collaborationUse.length() > 0
":InteractionUse" -> "sb:StringBuilder": append(collaborationUse + ".")
activate "sb:StringBuilder"
ref over "sb:StringBuilder" : sb.append(collaborationUse + ".") 
":InteractionUse" <<-- "sb:StringBuilder" 
deactivate "sb:StringBuilder"
end
":InteractionUse" -> "sb:StringBuilder": append(interactionName)
activate "sb:StringBuilder"
ref over "sb:StringBuilder" : sb.append(interactionName) 
":InteractionUse" <<-- "sb:StringBuilder" 
deactivate "sb:StringBuilder"
":InteractionUse" -> "sb:StringBuilder": append("(")
activate "sb:StringBuilder"
ref over "sb:StringBuilder" : sb.append("(") 
":InteractionUse" <<-- "sb:StringBuilder" 
deactivate "sb:StringBuilder"
":InteractionUse" -> "sb:StringBuilder": append(parameterListToSignateru())
activate "sb:StringBuilder"
ref over "sb:StringBuilder" : sb.append(parameterListToSignateru()) 
":InteractionUse" <<-- "sb:StringBuilder" 
deactivate "sb:StringBuilder"
":InteractionUse" -> "sb:StringBuilder": append(")")
activate "sb:StringBuilder"
ref over "sb:StringBuilder" : sb.append(")") 
":InteractionUse" <<-- "sb:StringBuilder" 
deactivate "sb:StringBuilder"
[<<-- ":InteractionUse"
deactivate ":InteractionUse"
@enduml
DEBUG: Added new method tab
DEBUG: Drawing sequence diagram for method: - parameterListToSignateru() : String
@startuml
scale 1.5
skinparam style strictuml
mainframe - parameterListToSignateru() : String
[-> ":InteractionUse" 
activate ":InteractionUse"
":InteractionUse" -->> "sb:StringBuilder" ** : <<create>>
opt parameterList.size() > 0
end
[<<-- ":InteractionUse"
deactivate ":InteractionUse"
@enduml
DEBUG: Java sequence diagram update completed
Saving scroll position - X: 0.0, Y: 0.0
DEBUG: Updating WebView with new SVG
CppModel classes: 1
  Class: A
Restored scroll position - X: 0.0, Y: 0.0
  Attributes: []
  Operations: [+ A(), + ~A()]
  Relations: 
DEBUG: CppClassDiagramDrawer - Number of classes: 1
Generated PlantUML:
@startuml
 skinparam linetype ortho
skinparam classAttributeIconSize 0
skinparam LineThickness 1.5
hide empty members
skinparam enumBackgroundColor White
skinparam enumBorderColor Black
scale 1.0
class A #90EE90 {
  + A()
  + {virtual} ~A()
}

@enduml

DEBUG: CppClassDiagramDrawer draw completed
Saving scroll position - X: 0.0, Y: 0.0
Restored scroll position - X: 0.0, Y: 0.0
Selected language: Java
DEBUG: Starting to draw Java class diagram
DEBUG: Found 16 classes to draw
Generated PlantUML:
@startuml
skinparam style strictuml
 skinparam linetype ortho
skinparam classAttributeIconSize 0
skinparam LineThickness 1.5
scale 1.0
class JavaModel { 
{field} - codeFileList : List<CodeFile> = new ArrayList<>()
{field} - translator : JavaTranslator = new JavaTranslator()
{method} + getInstance() : JavaModel
{method} # getCodeFileList() : List<? extends ICodeFile>
{method} + addNewCodeFile(fileName : String) : void
{method} + addNewUmlClass(umlClass : Class) : void
{method} + updateCodeFile(changedCodeFile : ICodeFile, code : String) : void
{method} + addAttribute(className : String, attribute : Attribute) : void
{method} + addOperation(className : String, operation : Operation) : void
{method} + addComposition(haveClassName : String, compositedClassName : String) : void
{method} + addGeneralization(generalizedClassName : String, superClassName : String) : void
{method} + delete(className : String) : void
{method} + delete(className : String, attribute : Attribute) : void
{method} + delete(className : String, operation : Operation) : void
{method} + delete(className : String, operation : Operation, interactionFragment : InteractionFragment) : void
{method} + deleteSuperClass(className : String) : void
{method} + addMessage(className : String, operation : Operation, message : Message) : void
{method} + findCodeFile(fileName : String) : Optional<CodeFile>
{method} + addCombinedFragment(className : String, operation : Operation, combinedFragment : CombinedFragment) : void
{method} # findMethodDeclaration(methodDeclarationList : List<MethodDeclaration>, operation : Operation) : Optional<MethodDeclaration>
}
JavaModel --|> AbstractJavaModel
JavaModel *--  " - model 1 " JavaModel
class CppRelationshipManager { 
{field} - relationshipsByTarget : Map<String,Set<RelationshipInfo>> = new HashMap<>()
{field} - sourceClassName : String
{method} + addRelationship(relationship : RelationshipInfo) : void
{method} + addRealization(interfaceName : String) : void
{method} + addInheritance(targetClass : String) : void
{method} + addComposition(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
{method} + addAggregation(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
{method} + addAssociation(targetClass : String, memberName : String, multiplicity : String, visibility : Visibility) : void
{method} + getRelationshipsWith(targetClass : String) : Set<RelationshipInfo>
{method} + getAllRelationships() : Set<RelationshipInfo>
{method} + getRelationshipsOfType(type : RelationType) : Set<RelationshipInfo>
{method} + generatePlantUmlRelationships() : String
{method} - appendRegularRelationship(sb : StringBuilder, relation : RelationshipInfo) : void
{method} - appendDependencyRelationships(sb : StringBuilder, dependencyMap : Map<String,Set<RelationType>>) : void
{method} - appendInheritanceRelationships(sb : StringBuilder, inheritanceMap : Map<String,RelationshipInfo>) : void
{method} + removeRelationshipsWith(targetClass : String) : void
{method} + removeRelationshipsOfType(type : RelationType) : void
{method} + validateRelationships() : List<String>
}
class CppHeaderClass { 
{field} - name : String = ""
{field} - isAbstruct : Boolean = false
{field} - isInterface : Boolean = false
{field} - isActive : Boolean
{field} - superClasses : List<CppHeaderClass> = new ArrayList<>()
{field} - attributeList : List<Attribute> = new ArrayList<>()
{field} - operationList : List<Operation> = new ArrayList<>()
{field} - interactionList : List<Interaction> = new ArrayList<>()
{field} - memberModifiers : Map<String,Set<Modifier>> = new HashMap<>()
{method} + addMemberModifier(memberName : String, modifier : Modifier) : void
{method} + getModifiers(memberName : String) : Set<Modifier>
{method} + addRelationship(relationship : RelationshipInfo) : void
{method} + getRelationships() : Set<RelationshipInfo>
{method} + getRelationshipManager() : CppRelationshipManager
{method} + getName() : String
{method} + setName(name : String) : void
{method} + getAbstruct() : Boolean
{method} + setAbstruct(abstruct : Boolean) : void
{method} + getInterface() : Boolean
{method} + setInterface(abstruct : Boolean) : void
{method} + getActive() : Boolean
{method} + setActive(active : Boolean) : void
{method} + getSuperClasses() : List<CppHeaderClass>
{method} + setSuperClass(superClass : CppHeaderClass) : void
{method} + getAttributeList() : List<Attribute>
{method} + getOperationList() : List<Operation>
{method} + getInteractionList() : List<Interaction>
{method} + addAttribute(attribute : Attribute) : void
{method} + addOperation(operation : Operation) : void
{method} + addOperation(operation : Operation, interaction : Interaction) : void
{method} + addInteraction(interaction : Interaction) : void
{method} + removeAttribute(attribute : Attribute) : void
{method} + removeOperation(operation : Operation) : void
{method} + removeInteraction(interaction : Interaction) : void
{method} + findOperation(operationId : String) : Optional<Operation>
{method} + findInteraction(operation : Operation) : Optional<Interaction>
{method} + findInteraction(operationName : String) : Optional<Interaction>
{method} + toString() : String
}
CppHeaderClass *--  " - relationshipManager 1 " CppRelationshipManager
class CppImplClass { 
{field} - methodLocals : Map<String,List<LocalVariable>>
{field} - includes : Set<String>
{field} - usingDirectives : Set<String>
{field} - name : String
{field} - type : String
{field} - initialValue : String
{field} - modifiers : Set<Modifier>
{method} + getName() : String
{method} + getType() : String
{method} + getInitialValue() : String
{method} + getModifiers() : Set<Modifier>
{method} + addLocalVariable(methodName : String, variable : LocalVariable) : void
{method} + getLocalVariables(methodName : String) : List<LocalVariable>
{method} + clearLocalVariables() : void
{method} + addInclude(include : String) : void
{method} + getIncludes() : Set<String>
{method} + addUsingDirective(using : String) : void
{method} + getUsingDirectives() : Set<String>
{method} + addMethodCall(targetClass : String, methodName : String, callingMethod : String) : void
{method} + addTemporaryObject(targetClass : String, context : String) : void
{method} + addParameterType(targetClass : String, paramName : String, methodName : String) : void
{method} + getRelationshipManager() : CppRelationshipManager
{method} + getRelationships() : Set<RelationshipInfo>
{method} - isBuiltInType(type : String) : boolean
{method} - extractClassName(type : String) : String
{method} - extractBaseType(type : String) : String
{method} + getHeaderClass() : CppHeaderClass
}
CppImplClass *--  " - headerClass 1 " CppHeaderClass
CppImplClass *--  " - relationshipManager 1 " CppRelationshipManager
class LocalVariable { 
{field} - name : String
{field} - type : String
{field} - initialValue : String
{field} - modifiers : Set<Modifier>
{method} + getName() : String
{method} + getType() : String
{method} + getInitialValue() : String
{method} + getModifiers() : Set<Modifier>
}
class Message { 
{field} - name : String = ""
{field} - parameterList : ArrayList<Parameter> = new ArrayList<>()
{field} - replyType : Type
{field} - messageSort : MessageSort = MessageSort.synchCall
{method} + getName() : String
{method} + getParameterList() : ArrayList<Parameter>
{method} + setParameterList(parameterList : ArrayList<Parameter>) : void
{method} + getReplyType() : Type
{method} + getMessageEnd() : OccurenceSpecification
{method} + getMessageSort() : MessageSort
{method} + setMessageSort(messageSort : MessageSort) : void
{method} + getSignature() : String
{method} - parameterListToSignateru() : String
{method} + toString() : String
}
Message *--  " - messageEnd 1 " OccurenceSpecification
class Lifeline { 
{field} - name : String = ""
{field} - type : String = ""
{method} + getName() : String
{method} + getType() : String
{method} + getSignature() : String
}
class InteractionUse { 
{field} - collaborationUse : String = ""
{field} - interactionName : String = ""
{field} - parameterList : List<Parameter> = new ArrayList<>()
{method} + getCollaborationUse() : String
{method} + getInteractionName() : String
{method} + getParameterList() : List<Parameter>
{method} + setCollaborationUse(collaborationUse : String) : void
{method} + getSignature() : String
{method} - parameterListToSignateru() : String
}
InteractionUse --|> InteractionFragment
class OccurenceSpecification { 
{field} - statement : Statement
{method} + getMessage() : Message
{method} + setMessage(message : Message) : void
{method} + getStatement() : Optional<Statement>
{method} + setStatement(statement : Statement) : void
{method} + toString() : String
}
OccurenceSpecification --|> InteractionFragment
OccurenceSpecification *--  " - message 1 " Message
class InteractionOperand { 
{field} - guard : String = ""
{method} + getGuard() : String
}
InteractionOperand --|> InteractionFragment
class Class { 
{field} - name : String = ""
{field} - isAbstruct : Boolean = false
{field} - isActive : Boolean
{field} - attributeList : List<Attribute> = new ArrayList<>()
{field} - operationList : List<Operation> = new ArrayList<>()
{field} - interactionList : List<Interaction> = new ArrayList<>()
{method} + getName() : String
{method} + setName(name : String) : void
{method} + getAbstruct() : Boolean
{method} + setAbstruct(abstruct : Boolean) : void
{method} + getActive() : Boolean
{method} + setActive(active : Boolean) : void
{method} + getSuperClass() : Optional<Class>
{method} + setSuperClass(superClass : Class) : void
{method} + getAttributeList() : List<Attribute>
{method} + getOperationList() : List<Operation>
{method} + getInteractionList() : List<Interaction>
{method} + addAttribute(attribute : Attribute) : void
{method} + addOperation(operation : Operation) : void
{method} + addOperation(operation : Operation, interaction : Interaction) : void
{method} + addInteraction(interaction : Interaction) : void
{method} + removeAttribute(attribute : Attribute) : void
{method} + removeOperation(operation : Operation) : void
{method} + removeInteraction(interaction : Interaction) : void
{method} + findOperation(operationId : String) : Optional<Operation>
{method} + findInteraction(operation : Operation) : Optional<Interaction>
{method} + findInteraction(operationName : String) : Optional<Interaction>
{method} + toString() : String
}
Class *--  " - superClass 1 " Class
abstract class InteractionFragment { 
{field} - interactionFragmentList : ArrayList<InteractionFragment> = new ArrayList<>()
{method} + getLifeline() : Lifeline
{method} + setLifeline(lifeline : Lifeline) : void
{method} + getInteractionFragmentList() : ArrayList<InteractionFragment>
{method} + setInteractionFragmentList(interactionFragmentList : ArrayList<InteractionFragment>) : void
}
InteractionFragment *--  " - lifeline 1 " Lifeline
class CombinedFragment { 
{field} - kind : InteractionOperandKind
{field} - interactionOperandList : ArrayList<InteractionOperand> = new ArrayList<>()
{field} - statement : Statement
{method} + getKind() : InteractionOperandKind
{method} + getInteractionOperandList() : ArrayList<InteractionOperand>
{method} + getStatement() : Optional<Statement>
{method} + setStatement(statement : Statement) : void
{method} + toString() : String
}
CombinedFragment --|> InteractionFragment
class Interaction { 
{field} - operation : Operation
{field} - name : String = ""
{field} - interactionFragmentList : ArrayList<InteractionFragment> = new ArrayList<>()
{method} + getOperation() : Operation
{method} + getName() : String
{method} + getInteractionFragmentList() : ArrayList<InteractionFragment>
{method} + deleteInteractionFragment(targetIf : InteractionFragment) : void
{method} - delete(targetIf : InteractionFragment, ifList : ArrayList<InteractionFragment>) : boolean
}
class RelationshipElement { 
{field} - name : String
{field} - elemType : ElementType
{field} - multiplicity : String
{field} - visibility : Visibility
{method} + getName() : String
{method} + getElemType() : ElementType
{method} + getMultiplicity() : String
{method} + getVisibility() : Visibility
}
class RelationshipInfo { 
{field} - targetClass : String
{field} - type : RelationType
{field} - elements : Set<RelationshipElement> = new HashSet<>()
{method} + addElement(name : String, elemType : ElementType, multiplicity : String, visibility : Visibility) : void
{method} + getTargetClass() : String
{method} + setType(type : RelationType) : void
{method} + getType() : RelationType
{method} + getElements() : Set<RelationshipElement>
}
@enduml

DEBUG: CppClassDiagramDrawer draw completed
DEBUG: Updating WebView with new SVG
Zoom set to: 1.684558823529412
Zoom set to: 1.670588235294118
Zoom set to: 1.6566176470588236
Zoom set to: 1.6286764705882355
Zoom set to: 1.586764705882353
Zoom set to: 1.5308823529411766
Zoom set to: 1.5029411764705884
Zoom set to: 1.4051470588235295
Zoom set to: 1.335294117647059
Zoom set to: 1.2794117647058825
Zoom set to: 1.223529411764706
Zoom set to: 1.209558823529412
Zoom set to: 1.1816176470588236
Zoom set to: 1.1676470588235295
Zoom set to: 1.1536764705882354
Zoom set to: 1.1397058823529413
Zoom set to: 1.1257352941176473
Zoom set to: 1.111764705882353
Zoom set to: 1.0838235294117646
Zoom set to: 1.0698529411764706
Zoom set to: 1.0419117647058824
Zoom set to: 1.0279411764705884
Zoom set to: 1.0
Zoom set to: 0.9720588235294119
Zoom set to: 0.9301470588235294
Zoom set to: 0.8742647058823529
Zoom set to: 0.8463235294117647
Zoom set to: 0.8183823529411764
Zoom set to: 0.8044117647058824
Zoom set to: 0.7904411764705882
Zoom set to: 0.7764705882352941
Zoom set to: 0.7625
Zoom set to: 0.7485294117647059
Zoom set to: 0.7345588235294118
Zoom set to: 0.7205882352941178
Zoom set to: 0.7066176470588236
Zoom set to: 0.6926470588235295
Zoom set to: 0.6786764705882354
Zoom set to: 0.6647058823529414
Zoom set to: 0.6507352941176471
Zoom set to: 0.636764705882353
Zoom set to: 0.6227941176470589
Zoom set to: 0.6088235294117649
